---
title: Object，Array
date: 2021-03-26 15:37:42
permalink: /pages/4372bd/
categories:
  - javascript
  - 集合引用类型
tags:
    -
---
## Object
显式的创建有两种方式：
1. 使用`new`操作符和`Object`构造函数。
```js
let person = new Object()
person.name = "Nicholas"
person.age = 29
```

2. 使用`对象字面量`表示法。
    对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建
```js
let person = {
  name:"Nicholas",
  age:29
}
```  
:::tip 注意
在使用对象字面量表示法定义对象时，并不会实际调用Object构造函数
:::

## Array
ECMAScript数组跟其他编程语言的数组有很大区别。跟其他语言中的数组一样，ECMAScript数组也是一组有序的数据，但跟其他语言不同的是，**数组中每个槽位可以存储任意类型的数**。这意味着可以创建一个数组，它的第一个元素是字符串，第二个元素是数值，第三个是对象。**ECMAScript数组也是动态大小的，会随着数据添加而自动增长。**
### 创建数组
1. 使用`Array`构造函数
```js
let colors = new Array()
```
如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后`length`属性就会被自动创建并设置为这个值。比如，下面的代码会创建一个初始`length`为20的数组：
```js
let colors = new Array(20)
```
也可以给`Array`构造函数传入要保存的元素。比如，下面的代码会创建一个包含3个字符串值的数组：
```js
let colors = new Array("red","blue","green")
```
创建数组时可以给构造函数传一个值。这个时候就有点问题了，因为如果这个值是一个数值，则会创建一个长度为指定数值的数组；而如果这个值是其他类型的，则会创建一个只包含该特定值的数组：
```js
let colors = new Array(3); //创建一个包含3个元素的数组
let names = new Array("Greg"); //创建一个只包含一个元素，即字符串"Greg"的数组
```
在使用`Array`构造函数时，也可以省略`new`操作符。结果是一样的。
```js
let colors = Array(3) //创建一个包含3个元素的数组
let names = Array("Greg") //创建一个只包含一个元素，即字符串"Greg"的数组
```
另一种创建数组的方式是使用`数组字面量`表示法。
```js
let colors = ["red","blue","green"] //创建一个包含3个元素的数组
let names = [] //创建一个空数组
let values = [1,2,] //创建一个包含2个元素的数组
```
:::tip 注意
与对象一样，在使用数组字面量表示法创建数组不会调用 `Array` 构造函数
:::

### Array.from() Array.of()
`Array`构造函数还有两个`ES6`新增的用于创建数组的静态方法：`from()`和`of()`。`from()`用于将类数组结构转换为数组实例。而`of()`用于将一组参数转换成数组实例。
`Array.from()`的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个`length`属性和可索引元素的结构。这种方式可以用于很多场合：
```js
//字符串会被拆分成单字符数组
console.log(Array.from("Matt")); //["M","a","t","t"]

//可以使用from()将集合和映射转换为一个新数组
const m = new Map().set(1,2)
                   .set(3,4)
const s = new Set().add(1)
                   .add(2)
                   .add(3)
                   .add(4)
console.log(Array.from(m)) // [[1,2],[3,4]]
console.log(Array.from(s)) //[1,2,3,4]     

//Array.form()对现有数组执行浅复制
const a1 = [1,2,3,4]
const a2 = Array.from(a1)

console.log(a1) //[1,2,3,4]
alert(a1 === a2) //false

//可以使用任何可迭代对象
const iter = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
  }
}

console.log(Array.from(iter)) // [1,2,3,4]

//arguments对象可以被轻松地转换为数组
function getArgsArray(){
  return Array.from(arguments)
}
console.log(getArgsArray(1,2,3,4)) //[1,2,3,4]

//from()也能转换带有必要属性的自定义对象
const arrayLikeObject = {
  0:1,
  1:2,
  2:3,
  3:4,
  length:4
}
console.log(Array.from(arrayLikeObject)) //[1,2,3,4]
```
`Array.from()`还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用`Array.from().map()`那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中的`this`值。但这个重写的`this`值在箭头函数中不适用。
```js
const a1 = [1,2,3,4];
const a2 = Array.from(a1,x => x**2);
const a3 = Array.from(a1,function(x){return x**this.exponent},{exponent:2});
console.log(a2); //[1,4,9,16]
console.log(a3); //[1,4,9,16]
```

`Array.of()`可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的`Array.prototype.slice.call(arguments)`,一种异常笨拙的将`arguments`对象转换为数组的写法：
```js
console.log(Array.of(1,2,3,4)); //[1,2,3,4]
console.log(Array.of(undefined)); //[undefined]
```

### 数组空位
使用数组字面量初始化数组时，可以使用一串逗号来创建空位。ECMAScript会将逗号之间相应索引位置的值当成空位，ES6规范重新定义了该如何处理这些空位。
可以像下面这样创建一个空位数组：
```js
const options = [,,,,,]; //创建包含5个元素的数组
console.log(options.length); //5
console.log(options); //[,,,,,]
```
ES6新增的方法和迭代器与早期ECMAScript版本中存在的方法行为不同。ES6新增方法普遍将这些空位当成存在的元素，之不过值为`undefined`:
```js
const options [1,,,,5];
for(const option of options){
  console.log(option === undefined)
}
//false
//true
//true
//true
//false

const a = Array.from([,,,]); //使用ES6的Array.from()创建的包含3个空位的数组
for(const val of a){
  alert(val === undefined);
}
//true
//true
//true

alert(Array.of(...[,,,])); //[undefined, undefined, undefined]
for(const [index,value] of options.entries()) {
  alert(value)
}
//1
//undefined
//undefined
//undefined
//5
```

ES6之前的方法则会忽略这个空位，但具体的行为也因方法而异：
```js
const options = [1,,,,5];
//map()会跳过空位置
console.log(options.map(() => 6)); //[6,undefined,undefined,undefined,6]

//join()视空位置为空字符串
console.log(options.join('-')); // "1----5
```

:::warning 注意
由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要，则可以显示地用undefined值代替
:::

### 数组索引
要取得或设置数组的值，需要使用中括号并提供相应值的数字索引：
```js
let colors = ["red","blue","green"]; //定义一个字符串数组
alert(colors[0]); //显示第一项
colors[2] = "black"; //修改第三项
colors[3] = "brown"; //添加第四项
```
在中括号中提供的索引表示要访问的值。如果索引小于数组包含的元素，则返回存储在相应位置的元素。
设置数组的方法也是一样的，就是替换指定位置的值。如果把一个值设置给超过数组最大索引的索引，就像示例中的colors[3],则数组长度会自动扩展到该索引值加1(示例中设置的索引3，索引数组长度变成了4)。
数组中元素的数量保存在`length`属性中,这个属性始终返回0或者大于0的值：
```js
let colors = ["red","blue","green"];
let names = []

alert(colors.length); //3
alert(colors.length); //0
```
数组`length`属性的独特之处在于，它不是只读的。通过修改`length`属性，可以从数组末尾删除或添加元素：
```js {2,3}
let colors = ["red","blue","green"];
colors.length = 2;
alert(colors[2]); //undefined
```
这里，数组`colors`一开始有3个值。将`length`设置为2，就删除了最后一个（位置2的）值，因为`colors[2]`就没有值了。如果将`length`设置为大于数组元素的值，则新添加的元素豆浆以`undefined`填充：
```js
let colors = ["red","blue","green"];
colors.length = 4;
alert(colors[3]); //undefined
```
这里将数组`length`属性设置为4，虽数组只包含了3个元素。位置3在数组中不存在，因此访问其值会返回特殊值`undefined`。
使用`length`属性可以方便地向数组末尾添加元素：
```js
let colors = ["red","blue","green"];
colors[colors.length] = "black"; //添加一种颜色（位置3）
colors[colors.length] = "brown"; //再添加一种颜色（位置4）
```

```js
let colors = ["red","blue","green"];
colors[99] = "black"; //添加一种颜色（位置99）
alert(colors.length); //100
```
这里，`colors`数组有一个值被插入到位置99，结果新`length`就变成了100(99+1)。这中间的所有元素，即位置3-98，实际并不存在，因此在访问时会返回`undefined`。
:::warning 注意
数组最多可以包含4294967295个元素，这对于大多数编程任务应该都足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误。
:::

### 检测数组
一个经典的ECMAScript问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用`instanceof`操作符就足矣：
```js
if(value instanceof Array){
  //操作数组
}
```
使用`instanceof`的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的`Array`构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。
为解决这个问题，ECMAScript提供了`Array.isArray()`方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的：
```js
if(Array.isArray(value)){
  //操作数组
}
```

### 迭代器方法
在ES6中，`Array`的原型上暴露了3个用于检索数组内容的方法：`keys()`,`values()`和`entries()`。
- `keys()`返回数组索引的迭代器
- `values()`返回数组元素的迭代器
- `entried()`返回 索引/值 对的迭代器

```js
const a = ["foo","bar","baz","qux"];

//因为这些方法都返回迭代器，所以可以将他们的内容通过Array.from()直接转换为数组实例
const aKeys = Array.from(a.keys()); //[0,1,2,3]
const aValues = Array.from(a.values()); //["foo","bar","baz","qux"]
const aEntries = Array.from(a.entries()); //[[0,"foo"],[1,"bar"],[2,"baz"],[3,"qux"]]
```
使用ES6的解构可以非常容易地在循环中拆分键/值对:
```js
for(const [idx,element] of a.entries()){
  alert(idx);
  alert(element);
}
//0
//foo
//1
//bar
//2
//baz
//3
//qux
```
:::warning 注意
虽然这些方法是ES6规范定义的，但在2017年底的时候仍有浏览器没有实现它们。
:::

### 复制和填充方法
ES6新增了两个方法：批量复制方法`copyWithin()`，以及填充数组方法`fill()`。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。