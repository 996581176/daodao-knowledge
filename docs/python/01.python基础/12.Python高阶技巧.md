---
title: Python高阶技巧
date: 2024-04-03 20:53:02
permalink: /pages/44ca69/
categories:
  - python
  - python基础
tags:
    -
---
## 闭包
在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个使用外部函数变量的内部函数称为闭包
```py
def account_create(initial_amount = 0):
    def atm(num, deposit=True):
        nonlocal initial_amount
        if deposit:
            initial_amount += num
        else:
            initial_amount -= num
    return atm
```

### 简单闭包
```py
def outer(logo):
    def inner(msg):
        print(f"<{logo}>{msg}<{logo}>")
    return inner

fn1 = outer("黑马程序员")
fn1("大家好呀") # <黑马程序员>大家好呀<黑马程序员>
fn1("学Python就来") # <黑马程序员>学Python就来<黑马程序员>

fn2 = outer("传智教育")
fn2("IT职业教育培训") # <传智教育>IT职业教育培训<传智教育>
fn2("学Python就来") # <传智教育>学Python就来<传智教育>
```
::: warning
需要使用nonlocal关键字修饰外部函数的变量，才可在内部函数中修改它
```py
def outer(num1):
    def inner(num2):
        nonlocal num1
        num1 += num2
        print(num1)
    return inner

fn = outer(10)
fn(10) # 20
fn(20) # 40
```
:::

### 闭包注意事项
优点，使用闭包可以让我们得到：  
- 无需定义全局变量即可实现通过函数，持续的访问、修改某个值  
- 闭包使用的变量的作用域在函数内，难以被错误的调用修改  

缺点：  
- 由于内部函数持续引用外部函数的值，所以会导致这一部分内存空间不被释放，一直占用内存。

## 装饰器
装饰器其实也是一种闭包，其功能就是在不破坏目标函数原因的代码和功能的前提下，为目标函数增加新功能。  
```py
def sleep():
    import random
    import time
    print("睡眠中......")
    time.sleep(random.randint(1, 5))
```

希望给sleep函数，增加一个功能：  
- 在调用sleep前输出：我要睡觉了  
- 在调用sleep后输出：我起床了

### 装饰器的一般写法（闭包写法）
```py
# 定义一个闭包函数，在闭包函数内部：
#   执行目标函数
#   并完成功能的添加
def outer(func):
    def inner():
        print("我要睡觉了")
        func()
        print("我起床了")
    return inner

def sleep():
    import random
    import time
    print("睡眠中......")
    time.sleep(random.randint(1, 5))

fn = outer(sleep)
fn()
```

### 装饰器的语法糖写法
使用@outer定义在目标函数sleep之上
```py
def outer(func):
    def inner():
        print("我要睡觉了")
        func()
        print("我起床了")
    return inner

@outer
def sleep():
    import random
    import time
    print("睡眠中......")
    time.sleep(random.randint(1, 5))

sleep()
```

## 设计模式
设计模式是一种编程套路，可以极大的方便程序的开发。最经典最常见、最经典的设计模式，就是我们所学习的面向对象了。

除了面向对象歪，在编程中也有很多既定的套路可以方便开发，我们称之为设计模式：  
- 单例、工厂模式  
- 建造者、责任链、状态、备忘录、解释器、访问者、观察者、中介、模板、代理模式  

### 单例模式
```py
class Tool:
    pass

t1 = Tool()
t2 = Tool()
print(t1)
print(t2)
```
创建类的实例后，就可以得到一个完整的、独立的对象。  
通过print语句可以看出，它们的内存地址是不相同的，即t1和t2是完全独立的两个对象。  

某些常见下，我们需要一个类无论多少次类对象，都仅仅提供一个具体的实例，用以节省创建类对象的开销和内存开销  

比如某些工具类，仅需要1个实例，即可在各处使用  

这就是单例模式所要实现的效果。

单例的实现模式：
```py
# 在一个文件中定义如上代码
class StrTools
    pass

str_tool = StrTools()
```
```py
# 在另一个文件中导入对象
from test import str_tool

s1 = str_tool
s2 = str_tool

# s1和s2是同一个对象
print(s1)
print(s2)
```

### 工厂模式
当需要大量创建一个类的实例的时候，可以使用工厂模式  
即，从原生的使用类的构造去创建对象的形式  
迁移到，基于工厂提供的方法去创建对象的形式  
```py
class Person:
    pass

class Worker(Person):
    pass

class Student(Person):
    pass

class Teacher(Person):
    pass

# worder = Worker()
# stu = Student()
# teacher = Teacher()

class Factory:
    def get_person(self, p_type):
        if p_type == 'w':
            return Worker()
        elif p_type == 's':
            return Student()
        else:
            return Teacher()

factory = Factory()
worker = factory.get_person('w')
stu = factory.get_person('s')
teacher = factory.get_person('t')
```
::: tip 使用工厂类的get_person()方法去创建具体的类对象优点：
- 大批量创建对象的时候有统一的入口，易于代码维护  
- 当发生修改，仅修改工厂类的创建方法即可  
- 符合现实世界的模式，即由工厂来制作产品(对象)
:::

## 多线程并行执行概念