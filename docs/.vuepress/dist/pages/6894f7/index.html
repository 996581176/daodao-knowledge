<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>正则表达式 | 刀刀的知识积累</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script>var _hmt = _hmt || [];
            (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?6371333d39195dbe958ef14c0a722ac4";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
            })();</script>
    <link rel="icon" href="/daodao-knowledge/img/newlogo.ico">
    <meta name="description" content="立志不再懒懒散散的小前端的知识库">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/daodao-knowledge/assets/css/0.styles.d60e167a.css" as="style"><link rel="preload" href="/daodao-knowledge/assets/js/app.0ecb9aa2.js" as="script"><link rel="preload" href="/daodao-knowledge/assets/js/8.57715c3b.js" as="script"><link rel="preload" href="/daodao-knowledge/assets/js/9.c51f6440.js" as="script"><link rel="preload" href="/daodao-knowledge/assets/js/57.fdb87f31.js" as="script"><link rel="prefetch" href="/daodao-knowledge/assets/js/1.ec9e032c.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/10.f052a51b.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/100.6061f59e.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/101.2cebb8c3.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/102.5d7cdc12.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/103.797259e4.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/104.93e0bc32.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/105.0c6bf883.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/106.9f3b85ce.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/107.b4e7be5a.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/108.46460c0b.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/109.ccd46826.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/11.caa7dd4e.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/110.3fed454f.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/111.be0b304e.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/112.d945c7fa.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/113.21bb2b7d.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/114.b1494a11.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/115.aabd3d07.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/116.ed6ff0ec.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/117.8682c60c.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/118.8d69e73d.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/119.c2a10698.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/12.c0426fe0.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/120.ce3ef543.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/121.2a0c8300.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/122.19cace7a.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/123.28279506.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/124.1cc00332.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/125.727191c8.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/126.d43fa41a.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/127.c37ff6c8.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/128.c2398019.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/129.9ad083a2.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/13.f1808158.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/130.b3edb667.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/131.d261cd5d.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/132.9054da37.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/133.a84d2628.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/134.1423f8eb.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/135.96fd649a.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/136.3ea7320a.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/137.ce34adf1.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/138.60b6b4f0.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/139.4f89a590.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/14.effea97b.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/140.90ad16e1.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/141.3a6af01f.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/142.65294786.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/143.f6333d0b.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/144.250ad550.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/145.81503528.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/146.2e403fb6.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/147.6649a159.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/148.bd2f7e53.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/149.c1f97199.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/15.bdb81540.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/150.101cecc8.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/151.16e83f57.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/152.b8e91ffd.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/16.76063f3f.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/17.4737cee7.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/18.96d1027b.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/19.edf9e05c.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/2.fc454403.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/20.50edee9e.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/21.c3434c77.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/22.91590454.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/23.76473a83.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/24.fa0905fc.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/25.a2b1cfbc.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/26.f81add96.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/27.ce92e19c.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/28.f1933965.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/29.a10b3707.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/3.d72005aa.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/30.6fb33b69.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/31.bbe6d778.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/32.9e007569.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/33.35df6a11.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/34.16ea7813.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/35.6e8f4891.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/36.b16062d2.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/37.79dc0067.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/38.9e559da5.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/39.e16b09c2.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/4.8d4e1f1b.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/40.c0ab9572.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/41.563d8275.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/42.66e49c60.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/43.b055daf7.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/44.66a3091e.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/45.00fd5684.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/46.6eb0fe94.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/47.491c22af.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/48.dafdc9ef.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/49.0898379a.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/5.9a8064df.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/50.7f2888db.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/51.4ef6521c.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/52.51be1beb.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/53.09b547bb.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/54.ba17abd9.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/55.7d977e62.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/56.e3ec10d0.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/58.3f247989.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/59.2760f717.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/6.21d0efb5.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/60.4468a3cd.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/61.8040acaf.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/62.f64690b2.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/63.010f89dd.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/64.c6a162c9.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/65.0196d204.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/66.387aacb3.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/67.2b58e7b5.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/68.034f6a42.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/69.c1a480fb.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/70.9fcc436e.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/71.0089623d.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/72.e8cd8ee8.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/73.90cd22c3.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/74.ef6debc8.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/75.694f5c70.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/76.2eb861b3.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/77.1a33040f.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/78.67fdbfbf.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/79.8b41df81.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/80.e8458357.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/81.85e9d7ae.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/82.884405b3.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/83.f30e0746.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/84.61f8acf8.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/85.96f12799.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/86.a7663ca1.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/87.543f2fe8.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/88.970e065e.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/89.d266f09f.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/90.994d5d32.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/91.f4d2e972.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/92.9d429644.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/93.d9765fc6.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/94.a5f3c4a4.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/95.419bc309.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/96.ef2a8990.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/97.b9eb2c72.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/98.2df38c31.js"><link rel="prefetch" href="/daodao-knowledge/assets/js/99.76bc7f69.js">
    <link rel="stylesheet" href="/daodao-knowledge/assets/css/0.styles.d60e167a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/daodao-knowledge/" class="home-link router-link-active"><img src="/daodao-knowledge/img/home.jpg" alt="刀刀的知识积累" class="logo"> <span class="site-name can-hide">刀刀的知识积累</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/daodao-knowledge/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端学习" class="dropdown-title"><span class="title">前端学习</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端学习" class="mobile-dropdown-title"><span class="title">前端学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/600fd9/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/12e2d5/" class="nav-link">
  算法&amp;常用方法
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/450a09/" class="nav-link">
  TypeScript
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/ffc1d9/" class="nav-link">
  css
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/a5dbfb/" class="nav-link">
  现代JavaScript库开发
</a></li></ul></li><li class="dropdown-item"><h4>
          框架学习
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/8ea889/" class="nav-link">
  react
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/3ba846/" class="nav-link">
  vuePress
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/347ae3/" class="nav-link">
  qiankun微前端
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/f97ef5/" class="nav-link">
  vue3
</a></li></ul></li><li class="dropdown-item"><h4>
          webgl学习
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/7fb7ad/" class="nav-link">
  threejs
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/e77551/" class="nav-link">
  the book of shaders
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端学习" class="dropdown-title"><span class="title">后端学习</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端学习" class="mobile-dropdown-title"><span class="title">后端学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/daodao-knowledge/pages/437984/" class="nav-link">
  python
</a></li></ul></div></div><div class="nav-item"><a href="/daodao-knowledge/pages/cd2a4f/" class="nav-link">
  零零碎碎
</a></div><div class="nav-item"><a href="/daodao-knowledge/pages/9d1205/" class="nav-link">
  随记
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><span class="title">索引</span> <span class="arrow down"></span></button> <button type="button" aria-label="索引" class="mobile-dropdown-title"><span class="title">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/daodao-knowledge/archives/" class="nav-link">
  归档
</a></li></ul></div></div><div class="nav-item"><a href="/daodao-knowledge/daodao/" class="nav-link">
  关于我
</a></div> <a href="https://github.com/Ostask/daodao-knowledge" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/daodao-knowledge/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端学习" class="dropdown-title"><span class="title">前端学习</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端学习" class="mobile-dropdown-title"><span class="title">前端学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/600fd9/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/12e2d5/" class="nav-link">
  算法&amp;常用方法
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/450a09/" class="nav-link">
  TypeScript
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/ffc1d9/" class="nav-link">
  css
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/a5dbfb/" class="nav-link">
  现代JavaScript库开发
</a></li></ul></li><li class="dropdown-item"><h4>
          框架学习
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/8ea889/" class="nav-link">
  react
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/3ba846/" class="nav-link">
  vuePress
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/347ae3/" class="nav-link">
  qiankun微前端
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/f97ef5/" class="nav-link">
  vue3
</a></li></ul></li><li class="dropdown-item"><h4>
          webgl学习
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/7fb7ad/" class="nav-link">
  threejs
</a></li><li class="dropdown-subitem"><a href="/daodao-knowledge/pages/e77551/" class="nav-link">
  the book of shaders
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端学习" class="dropdown-title"><span class="title">后端学习</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端学习" class="mobile-dropdown-title"><span class="title">后端学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/daodao-knowledge/pages/437984/" class="nav-link">
  python
</a></li></ul></div></div><div class="nav-item"><a href="/daodao-knowledge/pages/cd2a4f/" class="nav-link">
  零零碎碎
</a></div><div class="nav-item"><a href="/daodao-knowledge/pages/9d1205/" class="nav-link">
  随记
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><span class="title">索引</span> <span class="arrow down"></span></button> <button type="button" aria-label="索引" class="mobile-dropdown-title"><span class="title">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/daodao-knowledge/archives/" class="nav-link">
  归档
</a></li></ul></div></div><div class="nav-item"><a href="/daodao-knowledge/daodao/" class="nav-link">
  关于我
</a></div> <a href="https://github.com/Ostask/daodao-knowledge" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>变量、作用域与内存</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基本引用类型</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/daodao-knowledge/pages/6894f7/" aria-current="page" class="active sidebar-link">正则表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#正则表达式是什么" class="sidebar-link">正则表达式是什么</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#模糊匹配" class="sidebar-link">模糊匹配</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#横向模糊匹配" class="sidebar-link">横向模糊匹配</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#纵向模糊匹配" class="sidebar-link">纵向模糊匹配</a></li></ul></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#regexp" class="sidebar-link">RegExp</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#构造正则表达式" class="sidebar-link">构造正则表达式</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#模式标记-修饰符" class="sidebar-link">模式标记（修饰符）</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#实例属性" class="sidebar-link">实例属性</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#实例方法" class="sidebar-link">实例方法</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#构造函数属性" class="sidebar-link">构造函数属性</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#字符串的正则方法" class="sidebar-link">字符串的正则方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#字符" class="sidebar-link">字符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#单个字符" class="sidebar-link">单个字符</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#字符组" class="sidebar-link">字符组</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#范围表示法" class="sidebar-link">范围表示法</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#排除字符组" class="sidebar-link">排除字符组</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#常见的简写" class="sidebar-link">常见的简写</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#文字" class="sidebar-link">文字</a></li></ul></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#量词" class="sidebar-link">量词</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#贪婪模式" class="sidebar-link">贪婪模式</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#惰性模式" class="sidebar-link">惰性模式</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#独占模式-注意-注意-注意-javascript不支持独占模式" class="sidebar-link">独占模式（注意！注意！注意！Javascript不支持独占模式）</a></li></ul></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#位置匹配" class="sidebar-link">位置匹配</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#和" class="sidebar-link">^和$</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#b和-b" class="sidebar-link">\b和\B</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#p-和-p" class="sidebar-link">(?=p) 和 (?!p)</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#p-和-p-2" class="sidebar-link">(?&lt;=p) 和 (?&lt;!p)</a></li></ul></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#分组和分支" class="sidebar-link">分组和分支</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#分组" class="sidebar-link">分组</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#分支结构" class="sidebar-link">分支结构</a></li></ul></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#引用分组" class="sidebar-link">引用分组</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#提取数据" class="sidebar-link">提取数据</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#替换" class="sidebar-link">替换</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#反向引用" class="sidebar-link">反向引用</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#非捕获分组" class="sidebar-link">非捕获分组</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#分组别名" class="sidebar-link">分组别名</a></li></ul></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#断言匹配" class="sidebar-link">断言匹配</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#零宽先行断言-先行断言" class="sidebar-link">零宽先行断言(先行断言)</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#零宽后行断言-后行断言" class="sidebar-link">零宽后行断言（后行断言）</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#零宽负向先行断言-先行否定断言" class="sidebar-link">零宽负向先行断言（先行否定断言）</a></li><li class="sidebar-sub-header"><a href="/daodao-knowledge/pages/6894f7/#零宽负向后行断言-后行否定断言" class="sidebar-link">零宽负向后行断言（后行否定断言）</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>集合引用类型</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>期约与异步函数</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>客户端存储</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="page-content hasRightNav"><div class="right-nav" data-v-e3ddc674></div> <div class="article-title theme-default-content" data-v-fda27140><h1 data-v-fda27140><span class="circle" data-v-fda27140></span>正则表达式</h1> <div class="lastUpdatedTime" data-v-fda27140><span class="text" data-v-fda27140>更新时间:</span> 2024-03-04 14:58:18</div></div> <div class="theme-default-content content__default"><h2 id="正则表达式是什么"><a href="#正则表达式是什么" class="header-anchor">#</a> 正则表达式是什么</h2> <p>正则表达式其实就是一门工具，目的是为了字符串模式匹配，从而实现搜索和替换功能，它是一种用来描述规则的表达式，而它的底层原理也十分简单，就是使用状态机的思想进行模式匹配。</p> <h2 id="模糊匹配"><a href="#模糊匹配" class="header-anchor">#</a> 模糊匹配</h2> <h3 id="横向模糊匹配"><a href="#横向模糊匹配" class="header-anchor">#</a> 横向模糊匹配</h3> <p>横向模糊指的是，一个正则可匹配的字符串的<code>长度</code>是<code>不固定</code>的，可以是多种情况的。其实现的方式是使用量词，譬如<code>{m,n}</code>，表示连续出现<code>最少m次</code>，<code>最多n次</code>。<br>
比如 <code>/ab{2,5}c/</code> 表示匹配这样一个字符串：第一个字符是 a, 接下来是2到5个字符 b, 最后字符是 c</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ab{2,5}c</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;abc abbc abbbc abbbbc abbbbbc abbbbbbbc&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// [&quot;abbc&quot;, &quot;abbbc&quot;, &quot;abbbbc&quot;, &quot;abbbbbbc&quot;]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="纵向模糊匹配"><a href="#纵向模糊匹配" class="header-anchor">#</a> 纵向模糊匹配</h3> <p>纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。其实现的方式是使用字符组。譬如<code>[abc]</code>,表示该字符可以是a,b,c中的<code>任何一个</code>。比如<code>/a[123]b/</code>可以匹配如下三种字符串：&quot;a1b&quot;,&quot;a2b&quot;,&quot;a3b&quot;。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a[123]b</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;a0b a1b a2b a3b a4b&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// [&quot;a1b&quot;,&quot;a2b&quot;,&quot;a3b&quot;]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="regexp"><a href="#regexp" class="header-anchor">#</a> RegExp</h2> <h3 id="构造正则表达式"><a href="#构造正则表达式" class="header-anchor">#</a> 构造正则表达式</h3> <ul><li><strong>字面量形式</strong><br>
可以使用如下简洁语法构造正则表达式：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> expression <span class="token operator">=</span> <span class="token operator">/</span>pattern<span class="token operator">/</span>flags
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个正则表达式的<code>pattern（模式）</code>可以是任何简单或复杂的正则表达式。 每个正则表达式可以带零个或多个<code>flags(标记)</code>,用于控制正则的表达式的行为。</p> <ul><li><strong>使用RegExp构造函数</strong></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> expression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> flags<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>它接收两个参数： 模式字符串和标记字符串(可选的)。</p> <p>使用RegExp可以基于已有的正则表达式实例,并且可以选择性地修改他们的标记：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> re1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">cat</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>re1<span class="token punctuation">)</span> <span class="token comment">// /cat/g</span>

<span class="token keyword">const</span> re2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>re1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>re2<span class="token punctuation">)</span><span class="token comment">// /cat/g</span>

<span class="token keyword">const</span> re3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>re1<span class="token punctuation">,</span> <span class="token string">&quot;i&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>re3<span class="token punctuation">)</span> <span class="token comment">// /cat/i</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这两种方式是可以等价的，比如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 匹配第一个“bat”或“cat”,忽略大小写</span>
<span class="token keyword">let</span> pattern1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[bc]at</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span>

<span class="token comment">// 跟pattern1一样，只不过是用构造函数创建的</span>
<span class="token keyword">let</span> pattern2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&quot;[bc]at&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;i&quot;</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这里的pattern1和pattern2是等效的正则表达式。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>RegExp构造函数的两个参数都是字符串。因为RegExp的模式参数是字符串，所以在某些情况下需要二次转义。<br> <strong>所有元字符都必须二次转义，包括转义字符序列</strong>,如\n(<code>\</code>转义后的字符串是<code>\\</code>，在正则表达式字符串中则要写成<code>\\\\</code>)</p></div> <table><thead><tr><th>字面量模式</th> <th>对应字的符串</th></tr></thead> <tbody><tr><td><code>/\[bc\]at/</code></td> <td><code>&quot;\\[bc\\]at&quot;</code></td></tr> <tr><td><code>/\.at/</code></td> <td><code>&quot;\\.at&quot;</code></td></tr> <tr><td><code>/name\/age/</code></td> <td><code>&quot;name\\/age&quot;</code></td></tr> <tr><td><code>/\d.\d{1,2}/</code></td> <td><code>&quot;\\d.\\d{1,2}&quot;</code></td></tr> <tr><td><code>/\w\\hello\\123/</code></td> <td><code>&quot;\\w\\\\hello\\\\123&quot;</code></td></tr></tbody></table> <h3 id="模式标记-修饰符"><a href="#模式标记-修饰符" class="header-anchor">#</a> 模式标记（修饰符）</h3> <table><thead><tr><th>修饰符</th> <th>模式</th> <th>说明</th></tr></thead> <tbody><tr><td>g</td> <td>全局模式</td> <td>查找字符串的全部内容，而不是找到第一个匹配的内容就结束</td></tr> <tr><td>i</td> <td>不区分大小写</td> <td>在查找匹配时忽略pattern和字符串的大小写</td></tr> <tr><td>m</td> <td>多行模式</td> <td>查找到一行文本末尾时会继续查找</td></tr> <tr><td>y</td> <td>粘附模式</td> <td>只查找从lastIndex开始及之后的字符串</td></tr> <tr><td>u</td> <td>Unicode模式</td> <td>启用Unicode匹配</td></tr> <tr><td>s</td> <td>dotAll模式</td> <td>表示元字符.匹配任何字符(包括\n和\r)</td></tr></tbody></table> <h3 id="实例属性"><a href="#实例属性" class="header-anchor">#</a> 实例属性</h3> <p>每个RegExp都有下列属性：</p> <table><thead><tr><th>属性名</th> <th style="text-align:center;">类 型</th> <th>含义</th></tr></thead> <tbody><tr><td>global</td> <td style="text-align:center;">布尔值</td> <td>是否设置了g标记</td></tr> <tr><td>ignoreCase</td> <td style="text-align:center;">布尔值</td> <td>是否设置了i标记</td></tr> <tr><td>unicode</td> <td style="text-align:center;">布尔值</td> <td>是否设置了u标记</td></tr> <tr><td>sticky</td> <td style="text-align:center;">布尔值</td> <td>是否设置了y标记</td></tr> <tr><td>lastIndex</td> <td style="text-align:center;">整数</td> <td>在原字符串中下一次搜索的开始位置，始终从0开始</td></tr> <tr><td>multiline</td> <td style="text-align:center;">布尔值</td> <td>是否设置了m标记</td></tr> <tr><td>dotAll</td> <td style="text-align:center;">布尔值</td> <td>是否设置了s标记</td></tr> <tr><td>source</td> <td style="text-align:center;">字符串</td> <td>正则表达式的模式字符串，没有开头和结尾的斜杠</td></tr> <tr><td>flags</td> <td style="text-align:center;">字符串</td> <td>正则表达式的标记字符串</td></tr></tbody></table> <h3 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h3> <h4 id="exec"><a href="#exec" class="header-anchor">#</a> <code>exec()</code></h4> <p>主要用于配合捕获组使用。</p> <ul><li>参数<br>
这个方法只接收一个参数，即要应用模式的字符串。</li> <li>返回<br>
如果找到匹配项，返回第一个匹配信息的数组，这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串，如果模式中没有捕获组，则数组只包含一个元素。
如果没有找到匹配项，返回null</li></ul> <p>返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。</p> <ul><li>index是字符串中匹配的起始位置。</li> <li>input是要查找的字符串</li></ul> <p>如果模式设置了全局标记，则每次调用exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次exec(),也只会返回第一个匹配的信息</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> text <span class="token operator">=</span> <span class="token string">&quot;cat, bat, sat, fat&quot;</span>
<span class="token keyword">let</span> pattern <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">.at</span><span class="token regex-delimiter">/</span></span>

<span class="token keyword">let</span> matches <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token comment">//['cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pattern<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span> <span class="token comment">// 0</span>

matches <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token comment">//['cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pattern<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span> <span class="token comment">// 0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上面例子中的模式没有设置全局标记，因此调用<code>exec()</code>只返回<code>第一个</code>匹配项(&quot;cat&quot;),<code>lastIndex</code>在非全局模式下始终<code>不变</code>。</p> <p>如果在这个模式上设置了<code>g标记</code>，则每次调用<code>exec()</code>都会在字符串中<code>向前搜索下一个匹配项</code>：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> text <span class="token operator">=</span> <span class="token string">&quot;cat, bat, sat, fat&quot;</span>
<span class="token keyword">let</span> pattern <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">.at</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>

<span class="token keyword">let</span> matches <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token comment">//['cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pattern<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span> <span class="token comment">// 3</span>

matches <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token comment">//['bat', index: 5, input: 'cat, bat, sat, fat', groups: undefined]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pattern<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span> <span class="token comment">// 8</span>

matches <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token comment">//['sat', index: 10, input: 'cat, bat, sat, fat', groups: undefined]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pattern<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span> <span class="token comment">// 13</span>

matches <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token comment">//['fat', index: 15, input: 'cat, bat, sat, fat', groups: undefined]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pattern<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span> <span class="token comment">// 18</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>这次模式设置了全局标记，因此每次调用<code>exec()</code>都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。注意模式的<code>lastIndex</code>属性每次都会变化。</p> <p>在全局匹配模式下，每次调用exec()都会更新lastIndex值，以反应上次匹配的最后一个字符的索引。</p> <p>如果模式设置了<code>粘附标记y</code>,则每次调用exec()就只会在lastIndex的位置上寻找匹配项。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> text <span class="token operator">=</span> <span class="token string">&quot;cat, bat, sat, fat&quot;</span>
<span class="token keyword">let</span> pattern <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">.at</span><span class="token regex-delimiter">/</span><span class="token regex-flags">y</span></span>

<span class="token keyword">let</span> matches <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token comment">//['cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pattern<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span> <span class="token comment">// 3</span>

<span class="token comment">// 以索引3对应的字符串开头找不到匹配项，因此exec()返回null</span>
<span class="token comment">// exec() 没找到匹配项，于是将lastIndex设置为0</span>
matches <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token comment">// null</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pattern<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span> <span class="token comment">// 0</span>

<span class="token comment">// 向前设置lastIndex可以让沾附的模式通过exec()找到下一个匹配项</span>
pattern<span class="token punctuation">.</span>lastIndex <span class="token operator">=</span> <span class="token number">5</span>
matches <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token comment">// ['bat', index: 5, input: 'cat, bat, sat, fat', groups: undefined]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pattern<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span> <span class="token comment">// 8</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h4 id="test"><a href="#test" class="header-anchor">#</a> <code>test()</code></h4> <p>接收一个字符串，如果输入的文本与模式匹配，则参数返回true，否则返回false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。</p> <h3 id="构造函数属性"><a href="#构造函数属性" class="header-anchor">#</a> 构造函数属性</h3> <p>RegExp构造函数本身也有几个属性。(在其他语言中，这种属性被称为 静态属性)</p> <p>这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。</p> <p>这些属性还有一个特点，就是可以<strong>通过两种不同的方式访问它们</strong>，即，每个属性都有一个全名和一个简写：</p> <table><thead><tr><th>全名</th> <th>简写</th> <th>说明</th></tr></thead> <tbody><tr><td>input</td> <td>$_</td> <td>最后搜索的字符串(非标准特性)</td></tr> <tr><td>lastMatch</td> <td>$&amp;</td> <td>最后匹配的文本</td></tr> <tr><td>lastParen</td> <td>$+</td> <td>最后匹配的捕获组(非标准特性)</td></tr> <tr><td>leftContext</td> <td>$`</td> <td>input字符串中出现在lastMatch前面的文本</td></tr> <tr><td>rightContext</td> <td>$'</td> <td>input字符串中出现在lastMatch后面的文本</td></tr> <tr><td>$n</td> <td>$n</td> <td>n=1-9,可以最多存储9个捕获组的匹配项，这些属性通过RegExp.$1-RegExp.$9来访问。</td></tr></tbody></table> <h3 id="字符串的正则方法"><a href="#字符串的正则方法" class="header-anchor">#</a> 字符串的正则方法</h3> <h4 id="match"><a href="#match" class="header-anchor">#</a> <code>match()</code></h4> <p>这个方法本质上跟 RegExp 对象的 exec() 方法相同。这个方法接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象。返回也和exec()方法返回的数组是一样的。</p> <h4 id="search"><a href="#search" class="header-anchor">#</a> <code>search()</code></h4> <ul><li>参数：</li></ul> <ol><li>正则表达式字符串 或 RegExp对象</li></ol> <ul><li>返回模式第一个匹配的位置索引，如果没有找到则返回-1。</li></ul> <p>search()始终从字符串开头向后匹配模式。</p> <h4 id="replace"><a href="#replace" class="header-anchor">#</a> <code>replace()</code></h4> <ul><li>参数：</li></ul> <ol><li>第一个参数可以是一个RegExp对象或一个字符串</li> <li>第二个参数可以是一个字符串或一个函数。</li></ol> <p>如果第一个参数是字符串，那么只会替换第一个子字符串。<br>
要想替换所有字字符串，第一个参数必须为正则表达式并且带全局标记。</p> <p>replace()的第二个参数可以是一个函数。<br>
在只有一个匹配项时，这个函数会收到三个参数：</p> <ol><li>与整个模式匹配的字符串。</li> <li>匹配项在字符串中开始的位置。</li> <li>以及整个字符串<br>
在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。</li></ol> <p>这个函数应该返回一个字符串，表示应该把匹配项替换成什么。</p> <h4 id="split"><a href="#split" class="header-anchor">#</a> <code>split()</code></h4> <p>这个方法会根据传入的分隔符将字符串拆分成数组。</p> <p>参数：</p> <ol><li>作为分隔符的参数可以是字符串，也可以是RegExp对象。（字符串分隔符不会被这个方法当成正则表达式）</li> <li>还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小</li></ol> <h2 id="字符"><a href="#字符" class="header-anchor">#</a> 字符</h2> <h3 id="单个字符"><a href="#单个字符" class="header-anchor">#</a> 单个字符</h3> <p>最简单的正则表达式可以由简单的数字和字母组成，没有特殊的语义，纯粹就是一一对应的关系。如想在“apple”这个单词里找到&quot;a&quot;这个字符，就直接用 <code>/a/</code> 这个正则就可以了。</p> <p>有时候我们想去找到 <code>/</code> 字符，但是它在正则中有着特殊的意义该怎么办呢？所以就需要用到<code>转义符 \</code>。</p> <div class="custom-block tip"><p class="custom-block-title">\ 反斜杠表示转义符</p> <p>转义用于改变字符的含义，用来对某个字符有多种语义时的处理。</p></div> <p>如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等，而这些就需要我们使用转义符来匹配。</p> <table><thead><tr><th>匹配区间</th> <th style="text-align:center;">正则表达式</th> <th style="text-align:left;">记忆方式</th></tr></thead> <tbody><tr><td>换行符</td> <td style="text-align:center;">\n</td> <td style="text-align:left;">new line</td></tr> <tr><td>换页符</td> <td style="text-align:center;">\f</td> <td style="text-align:left;">form feed</td></tr> <tr><td>回车符</td> <td style="text-align:center;">\r</td> <td style="text-align:left;">return</td></tr> <tr><td>空白符</td> <td style="text-align:center;">\s</td> <td style="text-align:left;">space</td></tr> <tr><td>制表符</td> <td style="text-align:center;">\t</td> <td style="text-align:left;">tab</td></tr> <tr><td>垂直制表符</td> <td style="text-align:center;">\v</td> <td style="text-align:left;">vertical tab</td></tr> <tr><td>回退符</td> <td style="text-align:center;">[\b]</td> <td style="text-align:left;">backspace,之所以使用[]符号是避免和\b重复</td></tr></tbody></table> <div class="custom-block warning"><p class="custom-block-title">所有元字符必须转义</p> <p>元字符包括:<br> <code>( [ { \ ^ $ | ) ] } ? * + .</code></p></div> <h3 id="字符组"><a href="#字符组" class="header-anchor">#</a> 字符组</h3> <p>用<code>[]</code>括起来的字符，表示括号内的任一一个字符，记住是<code>其中一个</code>字符。例如<code>[abc]</code>，表示匹配一个字符，它可以是a,b,c之一。</p> <h3 id="范围表示法"><a href="#范围表示法" class="header-anchor">#</a> 范围表示法</h3> <p>字符组里的字符特别多的话，可以使用范围表示法。比如<code>[123456abcdefGHIJKLM]</code>，可以写成<code>[1-6a-fG-M]</code>。用连字符<code>-</code>来省略和简写。</p> <div class="custom-block warning"><p class="custom-block-title">Q：因为连字符有特殊用途，那么要匹配&quot;a&quot;、&quot;-&quot;、&quot;z&quot;这三者中任意一个字符，该怎么做呢</p> <p>A：不能写成<code>[a-z]</code>，因为连字符的存在，它表示小写字符中的任何一个字符。可以写成如下的方式：<br>
[-az]或[az-]或[a-z]。即要么放在开头，要么放在结尾，要么转义，总之不会让引擎认为是范围表示法就行了。</p></div> <h3 id="排除字符组"><a href="#排除字符组" class="header-anchor">#</a> 排除字符组</h3> <p>纵向模糊匹配中，还有一种情形就是，某位字符可以是任何东西，但就不能是“a”、“b”、“c”。</p> <p>此时就可以用排除字符组(反义字符组)。例如[^abc],表示是一个除“a”、“b、“c”之外的任一一个字符。字符组的第一位放<code>^</code>（脱字符）,表示求反的概念。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">1[^abc]2</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;1a2 1b2 1c2 1d2 147564872 1da2 1v2&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//  ['1d2', '1v2']</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当然也可以用连字符排除掉范围</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">1[^a-f]2</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;1a2 1b2 1c2 1d2 147564872 1da2 1v2 1f2&quot;</span>
string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span>
<span class="token comment">// ['1v2']</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="常见的简写"><a href="#常见的简写" class="header-anchor">#</a> 常见的简写</h3> <table><thead><tr><th style="text-align:left;">匹配区间</th> <th style="text-align:center;">简写</th> <th style="text-align:left;">正则</th> <th style="text-align:left;">记忆方式</th></tr></thead> <tbody><tr><td style="text-align:left;">单个数字</td> <td style="text-align:center;">\d</td> <td style="text-align:left;">[0-9]</td> <td style="text-align:left;">digit</td></tr> <tr><td style="text-align:left;">除了[0-9]</td> <td style="text-align:center;">\D</td> <td style="text-align:left;">[^0-9]</td> <td style="text-align:left;">Not digit</td></tr> <tr><td style="text-align:left;">包括下划线在内的单个字符</td> <td style="text-align:center;">\w</td> <td style="text-align:left;">[a-zA-Z0-9_]</td> <td style="text-align:left;">word</td></tr> <tr><td style="text-align:left;">非单字字符</td> <td style="text-align:center;">\W</td> <td style="text-align:left;">[^0-9a-zA-Z_]</td> <td style="text-align:left;">Not word</td></tr> <tr><td style="text-align:left;">空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符</td> <td style="text-align:center;">\s</td> <td style="text-align:left;">[ \t\v\n\r\f]</td> <td style="text-align:left;">space</td></tr> <tr><td style="text-align:left;">非空白符</td> <td style="text-align:center;">\S</td> <td style="text-align:left;">[^ \t\v\n\r\f]</td> <td style="text-align:left;">Not space</td></tr> <tr><td style="text-align:left;">除了换行符之外的任何字符</td> <td style="text-align:center;">.</td> <td style="text-align:left;"></td> <td style="text-align:left;"></td></tr></tbody></table> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>正则表达式中，点(<code>.</code>)是一个特殊字符，代表任一的单个字符，但是两个例外。
一个是四字节的UTF-16字符，这个可以用u修饰符解决<br>
另一个是行终止符，就是该字符表示一行的终结，以下四个字符属于行终止符</p> <ul><li>U+000A 换行符(\n)</li> <li>U+000D 回车符(\r)</li> <li>U+2028 行分隔符</li> <li>U+2029 段分隔符</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//因为.不匹配\n，所以正则表达式返回false。</span>
<span class="token operator">/</span>foo<span class="token punctuation">.</span>bar<span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'foo\nbar'</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></div> <p>如果要匹配任意字符怎么办？可以使用<code>[\d\D]</code>、<code>[\w\W]</code>、<code>[\s\S]</code>和<code>[^]</code>中任何的一个。</p> <h3 id="文字"><a href="#文字" class="header-anchor">#</a> 文字</h3> <p>Unicode是一种字符编码标准，用来表示各种语言的字符，使用<code>\u</code>加上四位十六进制数字，表示字符，例如表示汉字的正则是[\u4e00-\u9fa5]<br>
除此之外还有一些常用的字符：</p> <table><thead><tr><th style="text-align:left;">匹配范围</th> <th style="text-align:center;">正则</th> <th style="text-align:center;">unicode</th></tr></thead> <tbody><tr><td style="text-align:left;">NULL字符</td> <td style="text-align:center;">\0</td> <td style="text-align:center;">\u0000</td></tr> <tr><td style="text-align:left;">由十六进制数nn指定的拉丁字符，例如\x0A与\u000A相同</td> <td style="text-align:center;">\xnn</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:left;">由十六进制数字xxxx指定的Unicode字符;例如，\ u0009与\ t相同</td> <td style="text-align:center;">\uxxxx</td> <td style="text-align:center;"></td></tr></tbody></table> <h2 id="量词"><a href="#量词" class="header-anchor">#</a> 量词</h2> <table><thead><tr><th style="text-align:center;">符号</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">{m,n}</td> <td style="text-align:center;">重复m到n次</td></tr> <tr><td style="text-align:center;">{m,}</td> <td style="text-align:center;">至少出现m次</td></tr> <tr><td style="text-align:center;">{m}</td> <td style="text-align:center;">表示出现m次</td></tr> <tr><td style="text-align:center;">?</td> <td style="text-align:center;">等价于{0,1}，表示出现或者不出现</td></tr> <tr><td style="text-align:center;">+</td> <td style="text-align:center;">等价于{1,},表示至少出现一次</td></tr> <tr><td style="text-align:center;">*</td> <td style="text-align:center;">等价于{0,},表示出现任意次，可能不出现</td></tr></tbody></table> <h3 id="贪婪模式"><a href="#贪婪模式" class="header-anchor">#</a> 贪婪模式</h3> <p>看如下的例子：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d{2,5}</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;123 1234 12345 123456&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// ['123', '1234', '12345', '12345']</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个正则表示数字连续出现2-5次，会匹配2位，3位，4位，5位连续数字。</p> <p>但其实是贪婪的，它会尽可能多的匹配，正则表达式在进行重复匹配时，默认是贪婪模式。</p> <h3 id="惰性模式"><a href="#惰性模式" class="header-anchor">#</a> 惰性模式</h3> <p>但有时候我们并不需要贪婪模式，而惰性匹配，就是尽可能少的匹配, 我们可以通过在量词后加上<code>?</code>来开启惰性匹配</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d{2,5}?</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;123 1234 12345 123456&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// ['12', '12', '34', '12', '34', '12', '34', '56']</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个正则表示，虽然2到5次都行，当2个就够的时候，就不再往下尝试了。</p> <h3 id="独占模式-注意-注意-注意-javascript不支持独占模式"><a href="#独占模式-注意-注意-注意-javascript不支持独占模式" class="header-anchor">#</a> 独占模式（注意！注意！注意！Javascript不支持独占模式）</h3> <p>如果在表达式后加上一个加号<code>+</code>,则会开启独占模式。如同贪婪模式一样，独占模式一样会匹配最长。</p> <p>不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。</p> <p>以下是三种模式的表达式：</p> <table><thead><tr><th>贪婪</th> <th>懒惰</th> <th>独占</th></tr></thead> <tbody><tr><td>X?</td> <td>X??</td> <td>X?+</td></tr> <tr><td>X*</td> <td>X*?</td> <td>X*+</td></tr> <tr><td>X+</td> <td>X+?</td> <td>X++</td></tr> <tr><td>X{n}</td> <td>X{n}?</td> <td>X{n}+</td></tr> <tr><td>X{n,}</td> <td>X{n,}?</td> <td>X{n,}+</td></tr> <tr><td>X{n,m}</td> <td>X{n,m}?</td> <td>X{n,m}+</td></tr></tbody></table> <h2 id="位置匹配"><a href="#位置匹配" class="header-anchor">#</a> 位置匹配</h2> <h3 id="和"><a href="#和" class="header-anchor">#</a> ^和$</h3> <table><thead><tr><th>匹配内容</th> <th>表达式</th></tr></thead> <tbody><tr><td>匹配字符串的开始,在多行匹配中匹配行开头</td> <td>^</td></tr> <tr><td>匹配字符串的结束，在多行匹配中匹配行结尾</td> <td>$</td></tr></tbody></table> <p>比如我们把字符串的开头和结尾用&quot;#&quot;替换：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^|$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span><span class="token string">'#'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">//'#hello#'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>多行匹配模式时，二者是行的概念，这个需要我们注意：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;I\nlove\njavascript&quot;</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^|$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gm</span></span><span class="token punctuation">,</span><span class="token string">'#'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token comment">/*
#I#
#love#
#javascript#
*/</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="b和-b"><a href="#b和-b" class="header-anchor">#</a> \b和\B</h3> <p><code>\b</code> 是单词边界，具体就是 \w 和 \W之间的位置，也包括\w和^之间的位置，\w 和 $之间的位置。</p> <p>比如一个文件名是&quot;[JS] Lesson_01.mp4&quot;中的\b如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;[JS] Lesson_01.mp4&quot;</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\b</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span><span class="token string">'#'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// [#JS#] #Lesson_01#.#mp4#</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>首先，我们知道，\w是字符组[0-9a-zA-Z_]的简写形式，即\w是字母数字或者下划线的中任何一个字符。而\W是排除字符组[^0-9a-zA-Z_]的简写形式，即\W是\w以外的任何一个字符。</p> <p>此时我们可以看看&quot;[#JS#] #Lesson_01#.#mp4#&quot;中的每一个&quot;#&quot;，是怎么来的。</p> <p>第一个&quot;#&quot;，两边是&quot;[&quot;与&quot;J&quot;，是\W和\w之间的位置。
第二个&quot;#&quot;，两边是&quot;S&quot;与&quot;]&quot;，也就是\w和\W之间的位置。
第三个&quot;#&quot;，两边是空格与&quot;L&quot;，也就是\W和\w之间的位置。
第四个&quot;#&quot;，两边是&quot;1&quot;与&quot;.&quot;，也就是\w和\W之间的位置。
第五个&quot;#&quot;，两边是&quot;.&quot;与&quot;m&quot;，也就是\W和\w之间的位置。
第六个&quot;#&quot;，其对应的位置是结尾，但其前面的字符&quot;4&quot;是\w，即\w和$之间的位置。
知道了\b的概念后，那么\B也就相对好理解了。\B就是\b的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉\b，剩下的都是\B的。具体说来就是\w与\w、\W与\W、^与\W，\W与$之间的位置。</p> <p>比如把上面的例子，把所有\B替换成“#”：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;[JS] Lesson_01.mp4&quot;</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\B</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'#'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// #[J#S]# L#e#s#s#o#n#_#0#1.m#p#4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来，如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;The cat scattered his food all over the room&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>我想找到cat这个单词，但是如果只是使用<code>/cat/</code>这个正则，就会同时匹配到 cat 和 scattered 这两处文本。把正则表达式改一下<code>/\bcat\b/</code>这样就能匹配到cat这个单词了。</p> <h3 id="p-和-p"><a href="#p-和-p" class="header-anchor">#</a> (?=p) 和 (?!p)</h3> <p><code>(?=p)</code>，其中p是一个字模式，即p前面的位置。 比如(?=l),表示字符'l'前面的位置：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?=l)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span><span class="token string">'#'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// he#l#lo</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>而<code>(?!p)</code>就是<code>(?=p)</code>的反面意思，比如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?!l)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span><span class="token string">'#'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">//#h#ell#o#</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="p-和-p-2"><a href="#p-和-p-2" class="header-anchor">#</a> (?&lt;=p) 和 (?&lt;!p)</h3> <p><code>(?&lt;=p)</code>，其中p是一个字模式，即p后面的位置。 比如(?=l),表示字符'l'后面的位置：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;=l)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span><span class="token string">'#'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// hel#l#o</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>而<code>(?&lt;!p)</code>就是<code>(?&lt;=p)</code>的反面意思，比如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;!l)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span><span class="token string">'#'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// #h#e#llo#</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="分组和分支"><a href="#分组和分支" class="header-anchor">#</a> 分组和分支</h2> <p>更加高级的用法就得用到子表达式了，通过嵌套递归和自身引用可以让正则发挥更强大的功能。</p> <p>从简单到复杂的正则表达式演变通常要采用分组、回溯引用和逻辑处理的思想。利用这三种规则可以推演出无限复杂的正则表达式。</p> <div class="custom-block tip"><p class="custom-block-title">补充阅读</p> <h4 id="正则表达式引擎"><a href="#正则表达式引擎" class="header-anchor">#</a> 正则表达式引擎</h4> <p>之前我写webpack插件的时候写正则表达式让这个插件执行时间长达40多秒，一度让我怀疑人生，查过之后才发现是正则回溯陷阱。</p> <p>说起回溯陷阱，要先从正则表达式的引擎说起。正则引擎主要可以分为基本不同的两大类：</p> <ul><li>DFA 确定型有穷自动机
DFA对应的事文本主导的匹配，从左到右，每个字符不会匹配量词，它的时间复杂度是多项式的，所以通常情况下，它的速度更快，但支持的特效很少，不支持捕获组还有各种引用等。</li> <li>NFA 不确定型有穷自动机
NFA则是从正则表达式入手，不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，通常它的速度比较慢，最优时间复杂度为多项式的，最差情况为指数级的。但NFA支持更多的特性。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">to(nite|nighta|night)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> text <span class="token operator">=</span> <span class="token string">&quot;after tonight&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面的正则表达式在NFA匹配的时候，是根据正则表达式来匹配文本的，过程如下：</p> <ol><li>正则表达式第一个字符是 t，因为匹配文本中的第一个字符a, 失败继续往下</li> <li>t 匹配 文本中第二个字符 f ,失败继续往下</li> <li>t 匹配到了文本中的第三个字符 t，于是正则的第二个字符是 o ，匹配文本第四个字符e， 失败，正则回退到t，继续往下</li> <li>t 匹配到文本第7个字符 t， 然后 正则中的 o 也和文本第8个字符匹配， 继续往下</li> <li>正则表达式后面有三个可选条件，依次匹配，一个是 nite,失败，第二个是 nighta，也失败，第三个成功</li></ol> <p>而DFA匹配的时候，采用的是用文本来匹配正则表达式的方式，过程如下：</p> <ol><li>从文本第一个字符a开始匹配正则的t，失败继续往下</li> <li>匹配到文本第一个t，但e和正则中的o匹配失败，继续往下</li> <li>文本的第二个t匹配到正则的t，紧接着o也和正则的o匹配</li> <li>紧接着n匹配的时候发现正则里有三个可选匹配，文本中的g使第一个可选条件不匹配，继续匹配第二个，不匹配，继续匹配第三个，成功</li></ol> <p>可以看到DFA匹配过程中文本中的字符每个只比较了一次，没有吐出的操作，是快于NFA的。</p> <h4 id="正则回溯"><a href="#正则回溯" class="header-anchor">#</a> 正则回溯</h4> <p>说完了引擎，我们再来看看到底什么是回溯，对于下面这个表达式</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ab{1,3}c</span><span class="token regex-delimiter">/</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>对于文本“abbbc”,按照NFA引擎的匹配规则，其实是没有发生回溯的，在表达式a匹配完成后，b恰好和文本中的3个b完整匹配，之后是c匹配，一气呵成。<br>
但对于文本“abc”,无非就是少了两个字母b，却发生了回溯，匹配过程如下图所示（橙色为匹配，黄色为不匹配）。
<img src="https://daodaoblogpicgo.oss-cn-shanghai.aliyuncs.com/img/202403051508219.png" alt="">
为什么会发生回溯，这就是因为正则的贪婪特性，也就是说b{1,3}会竭尽所能的匹配最多的字符串。在第三步发生不匹配后，整个匹配流程并没有走完，而是像栈一样，将字符c吐出来，然后去用正则表达式中的c去和文本中的c进行匹配。这样就发生了一次回溯。</p> <p>而在懒惰模式下，正则引擎尽可能少的重复匹配字符，匹配成功之后它会继续匹配剩余的字符串</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ab{1,3}?c</span><span class="token regex-delimiter">/</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>则匹配过程变成了下面这样：
<img src="https://daodaoblogpicgo.oss-cn-shanghai.aliyuncs.com/img/202403051514126.png" alt=""></p> <p>而独占模式下，同贪婪模式一样，独占模式一样会匹配最长。不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。我们以下面的表达式为例，</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ab{1,3}+bc</span><span class="token regex-delimiter">/</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果我们用文本&quot;abbc&quot;去匹配上面的表达式，匹配的过程如下图所示
<img src="https://daodaoblogpicgo.oss-cn-shanghai.aliyuncs.com/img/202403051529029.png" alt="">
可以发现，在第2和第3步，b{1,3}+会将文本中的2个字母b都匹配上，结果文本中只剩下一个字母c。那么在第4步时，正则中的b和文本中的c进行匹配，当无法匹配时，并不进行回溯，这时候整个文本就无法和正则表达式发生匹配。如果将正则表达式中的加号（+）去掉，那么这个文本整体就是匹配的了。</p></div> <h3 id="分组"><a href="#分组" class="header-anchor">#</a> 分组</h3> <p>我们知道<code>/a+/</code>匹配连续出现的 a ,而需要匹配连续出现的 “ab”时，需要使用<code>/(ab)+/</code>。</p> <p>其中括号提供的是分组功能，能使量词 + 作用于括号内的整体：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(ab)+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;ababab abbb ababa&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// ['ababab', 'ab', 'abab']</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="分支结构"><a href="#分支结构" class="header-anchor">#</a> 分支结构</h3> <p>而在多选分支结构(p1|p2)中，此处括号的作用也是不言而喻的，提供了子表达式的所有可能。</p> <p>比如要匹配如下的字符串：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// I love JavaScript</span>
<span class="token comment">// I love Regular Expression</span>

 <span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^I love (JavaScript|Regular Expression)$</span><span class="token regex-delimiter">/</span></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&quot;I love JavaScript&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&quot;I love Regular Expression&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="引用分组"><a href="#引用分组" class="header-anchor">#</a> 引用分组</h2> <p>这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。</p> <p>以日期为例。假设格式是yyyy-mm-dd的，我们可以先写一个简单的正则：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d{4}-\d{2}|-\d{2}</span><span class="token regex-delimiter">/</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>然后再修改成括号版的：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{4})-(\d{2})-(\d{2})</span><span class="token regex-delimiter">/</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>接下来就看一下为什么要加括号：</p> <h3 id="提取数据"><a href="#提取数据" class="header-anchor">#</a> 提取数据</h3> <p>比如提取出年、月、日，可以这么做：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{4})-(\d{2})-(\d{2})</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;2024-03-06&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//  ['2024-03-06', '2024', '03', '06', index: 0, input: '2024-03-06', groups: undefined]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>match返回的一个数组：</p> <ul><li>第一个元素是整体匹配的结果</li> <li>然后是各个分组（括号里）匹配的内容</li> <li>然后是匹配下标index</li> <li>然后是输入文本 input</li> <li>最后是groups,命名分组，这个后面会讲到</li></ul> <p>另外也可以使用正则对象的 exec 方法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{4})-(\d{2})-(\d{2})</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;2024-03-06&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//  ['2024-03-06', '2024', '03', '06', index: 0, input: '2024-03-06', groups: undefined]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>也可以使用构造函数的全局属性 <code>$1</code> 至 <code>$9</code>来获取：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{4})-(\d{2})-(\d{2})</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;2024-03-06&quot;</span>
reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span> 
<span class="token comment">// reg.exex(string) 也可以</span>
<span class="token comment">// string.match(reg) 也可以</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">1</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">2</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">3</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="替换"><a href="#替换" class="header-anchor">#</a> 替换</h3> <p>比如，想把yyyy-mm-dd格式，替换成mm/dd/yyyy怎么做？</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{4})-(\d{2})-(\d{2})</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;2024-03-06&quot;</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">&quot;$2/$3/$1&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// 03/06/2024</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>其中，replace中的第二个参数里用 $1,$2,$3指代相应的分组。等价如下形式：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{4})-(\d{2})-(\d{2})</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;2024-03-06&quot;</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> RegExp<span class="token punctuation">.</span>$<span class="token number">2</span> <span class="token operator">+</span> <span class="token string">&quot;/&quot;</span> <span class="token operator">+</span> RegExp<span class="token punctuation">.</span>$<span class="token number">3</span> <span class="token operator">+</span> <span class="token string">&quot;/&quot;</span> <span class="token operator">+</span> RegExp<span class="token punctuation">.</span>$<span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// 03/06/2024</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>替换字符串可以插入下面的特殊变量名：</p> <table><thead><tr><th>变量</th> <th>说明</th></tr></thead> <tbody><tr><td>$$</td> <td>插入一个$</td></tr> <tr><td>$&amp;</td> <td>插入匹配的完整结果</td></tr> <tr><td>$`</td> <td>插入当前匹配的字符串左边的内容</td></tr> <tr><td>$'</td> <td>插入当前匹配的子串右边的内容</td></tr> <tr><td>$n</td> <td>插入第n个括号匹配的分组的内容，索引从1开始</td></tr></tbody></table> <p>测试如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">刀刀</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;#刀刀￥&quot;</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">&quot;$$$`$`$`$&amp;$'$'$'&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// 看这个替换的字符串，终于癫成了我想要的样子</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">//#$###刀刀￥￥￥￥</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="反向引用"><a href="#反向引用" class="header-anchor">#</a> 反向引用</h3> <p>除了使用相应API来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。</p> <p>还是以日期为例，比如要写一个正则支持匹配如下三种格式：</p> <ul><li>2024-03-06</li> <li>2024/03/06</li> <li>2024.03.06
最先想到的可能是：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d{4}(-|\/|\.)\d{2}(-|\/|\.)\d{2}</span><span class="token regex-delimiter">/</span></span>

<span class="token keyword">var</span> string1 <span class="token operator">=</span> <span class="token string">&quot;2024-03-06&quot;</span>
<span class="token keyword">var</span> string2 <span class="token operator">=</span> <span class="token string">&quot;2024/03/06&quot;</span>
<span class="token keyword">var</span> string3 <span class="token operator">=</span> <span class="token string">&quot;2024.03.06&quot;</span>
<span class="token keyword">var</span> string4 <span class="token operator">=</span> <span class="token string">&quot;2024-03/06&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string4<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>其中 / 和 . 需要转义。虽然匹配了要求的情况，但也匹配“2024-03/06”这样的数据。</p> <p>但是我们要的事分隔符前后一致，此时就需要使用反向引用：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d{4}(-|\/|\.)\d{2}\1\d{2}</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string1 <span class="token operator">=</span> <span class="token string">&quot;2024-03-06&quot;</span>
<span class="token keyword">var</span> string2 <span class="token operator">=</span> <span class="token string">&quot;2024/03/06&quot;</span>
<span class="token keyword">var</span> string3 <span class="token operator">=</span> <span class="token string">&quot;2024.03.06&quot;</span>
<span class="token keyword">var</span> string4 <span class="token operator">=</span> <span class="token string">&quot;2024-03/06&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string4<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>注意里面的 <code>\1</code>,表示引用之前的那个分组<code>(-|\/|\.)</code>。不管它匹配到什么，\1都匹配那个同样的具体某个字符。</strong></p> <p>\2 和 \3也就能理解了，分别指代第二个和第三个分组。</p> <div class="custom-block danger"><p class="custom-block-title">括号嵌套怎么办</p> <p>以左括号（ 为准：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^((\d)(\d(\d)))\1\2\3\4$</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;1231231233&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//123</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 23</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></div> <div class="custom-block danger"><p class="custom-block-title">\10表示什么呢</p> <p>\10是表示第10个分组，还是\1和0呢？答案是第10个分组。</p> <p>虽然正则里出现 \10 比较罕见：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;123456789# #######&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></div> <div class="custom-block danger"><p class="custom-block-title">引用不存在的分组会怎样？</p> <p>因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如 \2 ,就匹配 \2，注意 \2是对2进行转义。（关于转义，又是新的话题了，以后再讲，只需要知道\1-\7是有别的含义的转义字符）</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\1\2\3\4\5\6\7\8\9</span><span class="token regex-delimiter">/</span></span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&quot;\1\2\3\4\5\6\7\8\9&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;\1\2\3\4\5\6\7\8\9&quot;</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//['\x01\x02\x03\x04\x05\x06\x0789', index: 0, input: '\x01\x02\x03\x04\x05\x06\x0789', groups: undefined]</span>
<span class="token comment">//['\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07', '8', '9']</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></div> <h3 id="非捕获分组"><a href="#非捕获分组" class="header-anchor">#</a> 非捕获分组</h3> <p>之前文中出现的分组，都会捕获他们匹配到的数据，以便后续引用，因此也称他们是捕获型分组。</p> <p>如果只想要括号最原始的功能，但不会引用它，即，即不存在API里面，也不在正则里反向引用。此时可以使用非捕获分组<code>(?:p)</code>,这样可以避免浪费内存：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{4})-(?:\d{2})-(\d{2})</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;2024-03-06&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ['2024-03-06', '2024', '06', index: 0, input: '2024-03-06', groups: undefined]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 2024</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 06</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 空的，没有</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如果是嵌套分组非捕获呢,不会记录当前分组，子组不影响，该记录还是记录</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?:1(2)(?:3))(4)(?:5(6))</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;123456&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ['123456', '2', '4', '6', index: 0, input: '123456', groups: undefined]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 4</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 6</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">4</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">5</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$<span class="token number">6</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="分组别名"><a href="#分组别名" class="header-anchor">#</a> 分组别名</h3> <p>如果希望返回的组数据更清晰，可以给分组编号，将结果保存在返回的group字段中</p> <p>使用<code>?&lt;cont&gt;</code>起分组别名<br>
使用<code>$&lt;cont&gt;</code>读取别名</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;(?&lt;tag&gt;h[1-6])[\s\S]*&lt;\/\1&gt;</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;&lt;h1&gt; 你怎么这么优秀！&lt;/h1&gt;&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">/*
 [
    &quot;&lt;h1&gt; 你怎么这么优秀！&lt;/h1&gt;&quot;,
    &quot;h1&quot;,
    groups:{
        tag:&quot;h1&quot;
    },
    index:0,
    input:&quot;&lt;h1&gt; 你怎么这么优秀！&lt;/h1&gt;&quot;
 ]
*/</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="断言匹配"><a href="#断言匹配" class="header-anchor">#</a> 断言匹配</h2> <p>有时，我们需要限制适用范围，可以通过断言匹配达到这个目的。</p> <p>断言虽然卸载括号中，但它不是组，所以不会在匹配结果中保存，可以将断言理解为正则中的条件。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>断言用来声明一个应该为真的事实。正则表达式中只有断言为真时才会继续进行匹配。</p></div> <h3 id="零宽先行断言-先行断言"><a href="#零宽先行断言-先行断言" class="header-anchor">#</a> 零宽先行断言(先行断言)</h3> <p><code>(?=exp)</code>正向肯定查找，比如<code>x</code>只有在<code>y</code>前面才匹配，写成<code>/x(?=y)/</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 把张三女士的名字用括号括起来</span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;张三先生和张三女士&quot;</span>
<span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">张三(?=女士)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> result <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token string">&quot;($&amp;)&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> 
<span class="token comment">// 张三先生和(张三)女士</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="零宽后行断言-后行断言"><a href="#零宽后行断言-后行断言" class="header-anchor">#</a> 零宽后行断言（后行断言）</h3> <p><code>(?&lt;exp)</code>反向肯定查找。和先行断言相反，<code>x</code> 只有在<code>y</code>后面才匹配,写作<code>/(?&lt;=y)x/</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 找出李四今天花了多少钱</span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;张三:100,李四:250&quot;</span>
<span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;=李四:)\d+</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> result <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token comment">// ['250', index: 10, input: '张三:100,李四:250', groups: undefined]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 获取标题中的内容</span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;&lt;h1&gt;给刀刀点个赞吧&lt;/h1&gt;&quot;</span>
<span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;=&lt;h1&gt;).*(?=&lt;\/h1&gt;)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// ['给刀刀点个赞吧']</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="零宽负向先行断言-先行否定断言"><a href="#零宽负向先行断言-先行否定断言" class="header-anchor">#</a> 零宽负向先行断言（先行否定断言）</h3> <p><code>(?!exp)</code>正向否定查找，比如： <code>x</code>只有不在<code>y</code>前面在匹配，写成<code>/x(?!y)/</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 把非女士的张三名字用括号括起来</span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;张三先生和张三女士和张三人妖&quot;</span>
<span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">张三(?!女士)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> result <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token string">&quot;($&amp;)&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> 
<span class="token comment">// (张三)先生和张三女士和(张三)人妖</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="零宽负向后行断言-后行否定断言"><a href="#零宽负向后行断言-后行否定断言" class="header-anchor">#</a> 零宽负向后行断言（后行否定断言）</h3> <p><code>(?&lt;!exp)</code>反向否定查找，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 找出除了李四别人今天花了多少钱</span>
<span class="token keyword">var</span> string <span class="token operator">=</span> <span class="token string">&quot;张三:100,李四:250,王五:150,老六:400&quot;</span>
<span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(([^\d,])+?:(?&lt;!李四:)\d+)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> result <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token comment">// ['张三:100', '王五:150', '老六:400']</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>参考文献：</p> <ul><li><a href="https://zhuanlan.zhihu.com/p/514985360" target="_blank" rel="noopener noreferrer">一篇搞懂javascript正则表达式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://zhuanlan.zhihu.com/p/409033919" target="_blank" rel="noopener noreferrer">JS基础系列之 —— 正则表达式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/welson650/article/details/106277910?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-106277910-blog-88637519.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-106277910-blog-88637519.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;utm_relevant_index=6" target="_blank" rel="noopener noreferrer">正则表达式贪婪模式、懒惰模式与独占模式浅析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://es6.ruanyifeng.com/#docs/regex" target="_blank" rel="noopener noreferrer">正则的扩展 - ECMAScript6入门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>《JavaScript高级程序设计 第四版》</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/Ostask/daodao-knowledge/edit/master/docs/javascript/05.基本引用类型/01.正则表达式.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer></div> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/daodao-knowledge/pages/b3e22b/" class="prev">
        小结
      </a></span> <span class="next"><a href="/daodao-knowledge/pages/4372bd/">
        Object，Array
      </a>
      →
    </span></p></div>  <div class="footer">
    MIT Licensed | Copyright © 2021-present 刀刀
  </div></main></div><div class="global-ui"></div></div>
    <script src="/daodao-knowledge/assets/js/app.0ecb9aa2.js" defer></script><script src="/daodao-knowledge/assets/js/8.57715c3b.js" defer></script><script src="/daodao-knowledge/assets/js/9.c51f6440.js" defer></script><script src="/daodao-knowledge/assets/js/57.fdb87f31.js" defer></script>
  </body>
</html>
