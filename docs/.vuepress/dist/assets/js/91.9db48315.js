(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{538:function(e,t,r){"use strict";r.r(t);var a=r(47),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"问题描述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题描述"}},[e._v("#")]),e._v(" 问题描述")]),e._v(" "),r("p",[e._v("工作的时候，有个需求是将threejs渲染的画面保存成图片，但是当我用"),r("code",[e._v("renderer.documentElement.toDataUrl")]),e._v("得到的始终是黑色的图片。")]),e._v(" "),r("h2",{attrs:{id:"找寻原因"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#找寻原因"}},[e._v("#")]),e._v(" 找寻原因")]),e._v(" "),r("p",[e._v("其实这是 webgl 缓冲数据问题，你可以理解为会不停的清空画布然后再往上画下一帧，所以截屏的时候画布被清空了得到的是黑色的。")]),e._v(" "),r("h2",{attrs:{id:"解决问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解决问题"}},[e._v("#")]),e._v(" 解决问题")]),e._v(" "),r("p",[e._v("解决问题就很简单了，只需要在截屏的代码前加上"),r("code",[e._v("renderer.render(scene, camera)")]),e._v("，就可以解决问题了")])])}),[],!1,null,null,null);t.default=s.exports}}]);