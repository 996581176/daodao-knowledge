---
title: 期约
date: 2021-06-09 10:52:06
permalink: /pages/9ba128/
categories:
  - javascript
  - 期约与异步函数
tags:
    -
---
## 期约基础
ECMAScript6 新增的引用类型`Promise`，可以通过`new`操作符来实例化。创建新期约时需要传入执行器(executor)函数作为参数，下面例子使用了一个空函数对象来应付一下解释器：
```js
let p = new Promise(() => {})
setTimeout(console.log,0,p) // Promise<pending>
```
之所以说是应付解释器，是因为如果不提供执行函数，就会抛出`SyntaxError`。

### 1.期约状态机
在把一个期约实例传给`console.log()`时，控制台输出（可能因浏览器不同而略有差异）表明该实例处于**待定**（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下3种状态之一：
- 待定（pending）
- 兑现（fulfilled，有时候也称为“解决”，resolved）
- 拒绝（rejected）

**待定**（pending）是期约的最初始状态。在待定状态下，期约可以落定为代表成功的**兑现**（fulfilled）状态，或者代表失败的**拒绝**（rejected）状态。无论落为哪种状态都是不可逆的。只要从待定转换为兑现或者拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约解决（resolve）还是拒绝（reject），甚至永远处于待定（pending）状态，都应该有恰当的行为。

重要的是，期约的状态是私有的，不能直接通过JavaScript检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部JavaScript代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。

### 2.通过执行函数控制期约状态
由于期约状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为`resolve()`和`reject()`。调用`resolve()`会把状态切换成兑现，调用`reject()`会把状态切换为拒绝。另外，调用`reject()`也会抛出错误。

```js
let p1 = new Promise((resolve,reject) => resolve())
setTimeout(console.log,0,p1) //Promise<resolved>

let p1 = new Promise((resolve,reject) => reject())
setTimeout(console.log,0,p1) //Promise<rejected>
//Uncaught error(in promise)
```

在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态。这里的关键在于，执行器函数是**同步**执行的。这是因为执行器函数是期约的初始化程序。通过下面的例子可以看出上面代码的执行顺序：
```js
new Promise(() => setTimeout(console.log,0,'executor'))
setTimeout(console.log,0,'promise initialized')

// executor
// promise initialized
```
添加`setTimeout`可以推迟切换状态：
```js
let p = new Promise((resolve,reject) => setTimeout(resolve,1000))
//在console.log打印期约实例的时候，还不会执行超时回调（即resolve()）
setTimeout(console.log,0,p) //Promise<pending>
```
无论`resolve()`和`reject()`中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败：
```js
let p = new Promise((resolve,reject) => {
  resolve()
  reject() //没有效果
})
setTimeout(console.log,0,p) // Promise<resolved>
```
为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过`setTimeout`设置一个10秒钟后无论如何都会拒绝期约的回调：
```js
let p = new Promise((resolve,reject) => {
  setTimeout(reject,10000) //10秒后调用reject()
  //执行函数的逻辑
})

setTimeout(console.log,0,p) //Promise<pending>
setTimeout(console.log,11000,p) //11秒后检查状态

//(After 10 seconds) Uncaught error
//(After 11 seconds) Promise<rejected>
```
因为期约状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失效。

### 3.Promise.resolve()
期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用`Promise.resolve()`静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的：
```js
let p1 = new Promise((resolve,reject) => resolve())
let p1 = Promise.resolve()
```
这个解决期约的值对应着传给`Promise.resolve()`的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约：
```js
setTimeout(console.log,0,Promise.resolve())
//Promise<resolved>:undefined

setTimeout(console.log,0,Promise.resolve(3))
//Promise<resolved>:3

//多余的参数会忽略
setTimeout(console.log,0,Promise.resolve(4,5,6))
//Promise<resolved>:4
```
对这个静态方法而言，如果传入的参数本身就是一个期约，那它的行为就类似于一个空包装。因此，`Promise.resolve()`可以说是一个幂等方法，如下所示：
```js
let p = Promise.resolve(7)

setTimeout(console.log,0,p === Promise.resolve(p))
//true

setTimeout(console.log,0,p === Promise.resolve(Promise.resolve(p)))
//true
```
这个幂等性会保留传入期约的状态：
```js
let p = new Promise(() => {})

setTimeout(console.log,0,p) // Promise<pending>
setTimeout(console.log,0,Promise.resolve(p)) //Promise<pending>

setTimeout(console.log,0,p === Promise.resolve(p)) //true
```
注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为：
```js
let p = Promise.resolve(new Error('foo'))

setTimeout(console.log,0,p) 
//Promise<resolved>:Error:foo
```

### 4.Promise.reject()
与`Promise.resolve()`类似，`Promise.reject()`会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过`try/catch`捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实际上是一样的：
```js
let p1 = new Promise((resolve,reject) => reject())
let p1 = Promise.reject()
```
这个拒绝的期约的理由就是传给`Promise.reject()`的第一个参数。这个参数也会传给后续的拒绝处理程序：
```js
let p = Promise.reject(3)
setTimeout(console.log,0,p) // Promise<rejected>:3

p.then(null,(e) => setTimeout(console.log,0,e)) // 3
```
关键在于，`Promise.reject()`并没有照搬`Promise.resolve()`的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由
```js
setTimeout(console.log,0,Promise.reject(Promise.resolve()))
//Promise<rejected>:Promise<resolved>
```

### 5.同步/异步执行的二元性
`Promise`的设计很大程度上会导致一种完全不同于JavaScript的计算模式。下面的例子完美展示了这一点，其中包含了两种模式下抛出的错误的情形：
```js
try {
  throw new Error('foo')
} catch(e) {
  console.log(e) // Error:foo
}

try {
  Promise.reject(new Error('bar'))
} catch(e) {
  console.log(e)
}
//Uncaught (in Promise) Error : bar
```
第一个`try/cath`抛出并捕获了错误，第二个`try/catch`抛出错误却没有捕获到。乍一看这可能有点违反直觉，因为代码中确实是同步创建了一个拒绝的期约的实例，而这个实例也抛出了包含拒绝理由的错误。这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过**异步模式**捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。

在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，`try/catch`块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构，更具体说就是期约的方法。

## 期约的实例方法
期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。

### 1.Thenable接口
在ECMAScript暴露的异步结构中，任何对象都有一个`then()`方法。这个方法被认为实现了`Thenable`接口。下面的例子展示了实现这一接口的最简单的类：
```js
class MyThenable{
  then(){}
}
```

### 2.Promise.prototype.then()
`Promise.prototype.then()`是为期约实例添加处理程序的主要方法。这个`then()`方法接收最多两个参数：`onResolved`处理程序和`onRejected`处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。
```js
function onResolved(id){
  setTimeout(console.log,0,id,'resolved')
}
function onRejected(id){
  setTimeout(console.log,0,id,'rejected')
}

let p1 = new Promise((resolve,reject) => setTimeout(resolve,3000))
let p2 = new Promise((resolve,reject) => setTimeout(reject,3000))

p1.then(() => onResolved('p1'),
        () => onRejected('p1'))
p2.then(() => onResolved('p2'),
        () => onRejected('p2'))
        
//3秒后
//p1 resolved
//p2 rejected        
```
因为期约只能转换为最终状态1次，所以这两个操作一定是互斥的。

如前所述，两个处理程序参数都是可选的。而且，传给`then()`的任何非函数类型的参数都会被静默忽略。如果想只提供`onRejected`参数，那就要在`onResolved`参数的位置上传入`undefined`。这样有助于避免在内存中创建多余的对象，对期待函数参数的类型系统也是一个交代。

```js
function onResolved(id){
  setTimeout(console.log,0,id,'resolved')
}
function onRejected(id){
  setTimeout(console.log,0,id,'rejected')
}

let p1 = new Promise((resolve,reject) => setTimeout(resolve,3000))
let p2 = new Promise((resolve,reject) => setTimeout(reject,3000))

//非函数处理程序会被静默忽略，不推荐
p1.then('globbekfdsafe')

//不传onResolved处理程序的规范写法
p1.then(null,() => onRejected('p2'))

// p2 rejected (3秒后)
```

`Promise.prototype.then()`方法返回一个新的期约实例：

```js
let p1 = new Promise(() => {})
let p2 = p1.then()
setTimeout(console.log,0,p1) //Promise<pending>
setTimeout(console.log,0,p2) //Promise<pending>
setTimeout(console.log,0,p1 === p2) //false
```
这个新期约实例基于`onResolved`处理程序的返回值构建。换句话说，该处理程序的返回值会通过`Promise.resolve()`包装来生成新期约。如果没有提供这个处理程序，则`Promise.resolve()`就会包装上一个期约解决之后的值。如果没有显示的返回语句，则`Promise.resolve()`会包装默认的返回值`undefined`。

```js
let p1 = Promise.resolve('foo')

//若调用then()时不传处理程序，则原样向后传
let p2 = p1.then()

setTimeout(console.log,0,p2) // Promise<resolved>:foo

//这些都一样
let p3 = p1.then(() => undefined)
let p4 = p1.then(() => {})
let p5 = p1.then(() => Promise.resolve())

setTimeout(console.log,0,p3) //Promise<resolved>:undefined
setTimeout(console.log,0,p4) //Promise<resolved>:undefined
setTimeout(console.log,0,p5) //Promise<resolved>:undefined
```

如果有显式的返回值，则`Promise.resolve()`会包装这个值：
```js
//这些都一样
let p6 = p1.then(() => 'bar')
let p7 = p1.then(() => Promise.resolve('bar'))

setTimeout(console.log,0,p6) // Promise<resolved>:bar
setTimeout(console.log,0,p7) // Promise<resolved>:bar

//Promise.resolve()保留返回的期约
let p8 = p1.then(() => new Promise(() => {}))
let p9 = p1.then(() => Promise.reject())
// Uncautght (in promise):undefined

setTimeout(console.log,0,p8) // Promise<pending>
setTimeout(console.log,0,p9) //Promise<rejected>:undefined
```
抛出异常会返回拒绝的期约：
```js
let p10 = p1.then(() => {throw 'baz'})
//Uncaught (in promise) baz

setTimeout(console.log,0,p10) //Promise<rejected> baz
```
注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：
```js
let p11 = p1.then(() =>  Error('qux'))
setTimeout(console.log,0,p11) // Promise<rejected>:Error : qux
```
`onRejected`处理程序也与之类似：`onRejected`处理程序返回的值也会被`Promise.resolve()`包装。乍一看这可能有点违反直觉，但是想一想，`onRejected`处理程序的任务不就是捕获异步错误吗？因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约。

下面的代码片段展示了用`Promise.reject()`替代之前例子中的`Promise.resolve()`之后的结果：
```js
let p1 = Promise.reject('foo')

// 调用then()时不传处理程序则原样向后传
let p2 = p1.then()
//Uncaught (in promise) foo
setTimeout(console.log,0,p2) //Promise<rejected>： foo

//这些都一样
let p3 = p1.then(null,() => undefined)
let p4 = p1.then(null,() => {})
let p5 = p1.then(null,() => Promise.resolve())

setTimeout(console.log,0,p3) // Promise<resolved>:undefined
setTimeout(console.log,0,p4) // Promise<resolved>:undefined
setTimeout(console.log,0,p5) // Promise<resolved>:undefined

//这些都一样
let p6 = p1.then(null,() => 'bar')
let p7 = p1.then(null,() => Promise.resolve('bar'))

setTimeout(console.log,0,p6) // Promise<resolved>:bar
setTimeout(console.log,0,p7) // Promise<resolved>:bar

//Promise.resolve()保留返回的期约
let p8 = p1.then(null,() => new Promise(() => {}))
let p9 = p1.then(null,() => Promise.reject())
//Uncaught (in Promise) :undefined

setTimeout(console.log,0,p8) // Promise<pending>
setTimeout(console.log,0,p9) // Promise<rejected>:undefined

let p10 = p1.then(null,() => {throw 'baz'})
//Uncaught (in promise) baz

setTimeout(console.log,0,p10) //Promise<rejected>:baz

let p11 = p1.then(null,() => Error('qux'))
setTimeout(console.log,0,p11) //Promise<resolved>:Error:qux
```

### 3.Promise.prototype.catch()
`Promise.prototype.catch()`方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：`onRejected`处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用`Promise.prototype.then(null,onrejected)`。

下面代码展示了这两种同样的情况：
```js
let p = Promise.reject()
let onRejected = function(e) {
  setTimeout(console.log,0,'rejected')
}

//这两种添加拒绝处理程序的方式是一样的：
p.then(null,onRejected); //rejected
p.catch(onRejected)
```
`Promise.prototype.catch()`返回一个新的期约实例：

<script>

</script>