---
title: Python高阶技巧
date: 2024-04-03 20:53:02
permalink: /pages/44ca69/
categories:
  - python
  - python基础
tags:
    -
---
## 闭包
在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个使用外部函数变量的内部函数称为闭包
```py
def account_create(initial_amount = 0):
    def atm(num, deposit=True):
        nonlocal initial_amount
        if deposit:
            initial_amount += num
        else:
            initial_amount -= num
    return atm
```

### 简单闭包
```py
def outer(logo):
    def inner(msg):
        print(f"<{logo}>{msg}<{logo}>")
    return inner

fn1 = outer("黑马程序员")
fn1("大家好呀") # <黑马程序员>大家好呀<黑马程序员>
fn1("学Python就来") # <黑马程序员>学Python就来<黑马程序员>

fn2 = outer("传智教育")
fn2("IT职业教育培训") # <传智教育>IT职业教育培训<传智教育>
fn2("学Python就来") # <传智教育>学Python就来<传智教育>
```
::: warning
需要使用nonlocal关键字修饰外部函数的变量，才可在内部函数中修改它
```py
def outer(num1):
    def inner(num2):
        nonlocal num1
        num1 += num2
        print(num1)
    return inner

fn = outer(10)
fn(10) # 20
fn(20) # 40
```
:::

### 闭包注意事项
优点，使用闭包可以让我们得到：  
- 无需定义全局变量即可实现通过函数，持续的访问、修改某个值  
- 闭包使用的变量的作用域在函数内，难以被错误的调用修改  

缺点：  
- 由于内部函数持续引用外部函数的值，所以会导致这一部分内存空间不被释放，一直占用内存。

## 装饰器
装饰器其实也是一种闭包，其功能就是在不破坏目标函数原因的代码和功能的前提下，为目标函数增加新功能。  
```py
def sleep():
    import random
    import time
    print("睡眠中......")
    time.sleep(random.randint(1, 5))
```

希望给sleep函数，增加一个功能：  
- 在调用sleep前输出：我要睡觉了  
- 在调用sleep后输出：我起床了

### 装饰器的一般写法（闭包写法）
```py
# 定义一个闭包函数，在闭包函数内部：
#   执行目标函数
#   并完成功能的添加
def outer(func):
    def inner():
        print("我要睡觉了")
        func()
        print("我起床了")
    return inner

def sleep():
    import random
    import time
    print("睡眠中......")
    time.sleep(random.randint(1, 5))

fn = outer(sleep)
fn()
```

### 装饰器的语法糖写法
使用@outer定义在目标函数sleep之上
```py
def outer(func):
    def inner():
        print("我要睡觉了")
        func()
        print("我起床了")
    return inner

@outer
def sleep():
    import random
    import time
    print("睡眠中......")
    time.sleep(random.randint(1, 5))

sleep()
```

## 设计模式
设计模式是一种编程套路，可以极大的方便程序的开发。最经典最常见、最经典的设计模式，就是我们所学习的面向对象了。

除了面向对象歪，在编程中也有很多既定的套路可以方便开发，我们称之为设计模式：  
- 单例、工厂模式  
- 建造者、责任链、状态、备忘录、解释器、访问者、观察者、中介、模板、代理模式  

### 单例模式
```py
class Tool:
    pass

t1 = Tool()
t2 = Tool()
print(t1)
print(t2)
```
创建类的实例后，就可以得到一个完整的、独立的对象。  
通过print语句可以看出，它们的内存地址是不相同的，即t1和t2是完全独立的两个对象。  

某些常见下，我们需要一个类无论多少次类对象，都仅仅提供一个具体的实例，用以节省创建类对象的开销和内存开销  

比如某些工具类，仅需要1个实例，即可在各处使用  

这就是单例模式所要实现的效果。

单例的实现模式：
```py
# 在一个文件中定义如上代码
class StrTools
    pass

str_tool = StrTools()
```
```py
# 在另一个文件中导入对象
from test import str_tool

s1 = str_tool
s2 = str_tool

# s1和s2是同一个对象
print(s1)
print(s2)
```

### 工厂模式
当需要大量创建一个类的实例的时候，可以使用工厂模式  
即，从原生的使用类的构造去创建对象的形式  
迁移到，基于工厂提供的方法去创建对象的形式  
```py
class Person:
    pass

class Worker(Person):
    pass

class Student(Person):
    pass

class Teacher(Person):
    pass

# worder = Worker()
# stu = Student()
# teacher = Teacher()

class Factory:
    def get_person(self, p_type):
        if p_type == 'w':
            return Worker()
        elif p_type == 's':
            return Student()
        else:
            return Teacher()

factory = Factory()
worker = factory.get_person('w')
stu = factory.get_person('s')
teacher = factory.get_person('t')
```
::: tip 使用工厂类的get_person()方法去创建具体的类对象优点：
- 大批量创建对象的时候有统一的入口，易于代码维护  
- 当发生修改，仅修改工厂类的创建方法即可  
- 符合现实世界的模式，即由工厂来制作产品(对象)
:::

## 多线程并行执行概念
### 进程、线程
现代操作系统比如Mac OS X,UNIX,Linux,Windows等，都是支持“多任务”的操作系统。  
进程： 就是一个程序，运行在系统之上，那么便称之为这个程序为一个运行进程，并分配进程ID方便系统管理。  
现成： 线程是归属于进程的，一个进程可以开启多个线程，执行不同的工作，是进程的实际工作最小单位。  

进程就好比一家公司，是操作系统对程序进行运行管理的单位  
现成就好比公司的员工，进程可以有多个线程，是进程实际的工作者  

操作系统中可以运行多个进程，即多任务运行  
一个进程内可以运行多个线程，即多线程运行  

::: warning
进程之间是内存隔离的，即不同的进程拥有各自的内存空间，这就类似于不同的公司拥有不同的办公场所。  

线程之间是内存共享的，线程是属于进程的，一个进程内的多个线程之间是共享这个进程所拥有的内存空间的，这就好比，公司员工之间是共享公司的办公场所。  
:::

### 并行执行
并行执行的意思指的是同一时间做不同的工作。  
进程之间就是并行执行的，操作系统可以同时运行好多程序，这些程序都是在并行执行。  

除了进程外，线程其实也是可以并行执行的。一个程序在同一时间做两件乃至多件不同的事情，我们就称之为：多线程并行执行。

## 多线程编程
### threading模块
绝大多数编程语言，都允许多线程编程，Python也不例外。  
Python的多线程可以通过threading模块来实现。  

```py
import threading

thread_obj = threading.Thread([group [, target [, name [, args [, kwargs]]]]])
# group: 暂时无用，未来功能的预留参数
# target：执行的目标任务名
# args: 以元组的方式给执行任务传参
# kwargs: 以字典方式给执行任务传参
# name: 线程名，一般不用设置

# 启动线程，让线程开始工作
thread_obj.start()
```

示例：通过下面代码，即可实现多线程编程，让一个Python程序实现启动两个线程，每个线程各执行一个函数。
```py
import time
import threading

def sing():
    while True:
        print("我在唱歌，啦啦啦...")
        time.sleep(1)

def dance(msg):
    while True:
        print("我在跳舞，哗哗哗...")
        time.sleep(1)

# 创建一个唱歌的线程
sing_thread = threading.Thread(target=sing)

# 创建一个跳舞的线程
dance_thread = threading.Thread(target=dance)

# 让线程去干活吧
sing_thread.start()
dance_thread.start()
```

需要传参的话可以通过：  
- args参数通过元组（按参数顺序）的方式传参  
- 或使用kwargs参数用字典的形式传参  
```py
import time
import threading

def sing(msg):
    while True:
        print(f"我在唱歌，{msg}...")
        time.sleep(1)

def dance(msg):
    while True:
        print(f"我在跳舞，{msg}...")
        time.sleep(1)

# 创建一个唱歌的线程
sing_thread = threading.Thread(target=sing, args=("哈哈哈",))

# 创建一个跳舞的线程
dance_thread = threading.Thread(target=dance, kwargs={"msg":"啦啦啦"})

# 让线程去干活吧
sing_thread.start()
dance_thread.start()
```

## 网络编程
### Socket
socket是进程之间通信的工具，好比显示生活中的插座，所有的家用电器要想工作都是基于插座进行，进程之间想要进行网络通信需要socket。  
Socket负责进程之间的网络数据传输，好比数据的搬运工。

### 客户端和服务端
2个进程之间通过Socket进行相互通讯，就必须有服务端和客户端

Socket服务端：等待其它进程的连接，可接受发来的消息，可以回复消息  
Socket客户端：主动连接服务端，可以发送消息，可以接收回复
![](https://daodaoblogpicgo.oss-cn-shanghai.aliyuncs.com/img/202404080945722.png)

### Socket服务端编程
主要分为如下几个步骤：  
1. 创建socket对象
```py
import socket
socket_server = socket.socket()
```

2. 绑定socket_server到指定IP和地址
```py
socket_server.bind(host, port)
```

3. 服务端开始监听端口
```py
socker_server.listen(backlog)
# backlog为int整数，表示允许的连接数量，超出的会等待，可以不填，不填会自动设置一个合理值
```

4. 收客户端连接，获得连接对象
```py
conn, address = socket_server.accept()
print(f"接收到客户端连接，连接来自：{address}")
# accept方法是阻塞方法，如果没有连接，会卡再当前这一行不乡下执行代码
# accept返回的事一个二元元组，可以使用上述形式，用两个变量接收二元元组的2个元素
```

5. 客户端连接后，通过recv方法，接收客户端发送的消息
```py
while True:
    data = conn.recv(1024).decode("UTF-8")
    # recv方法返回值是字节数组（Bytes),可以通过decode使用UTF-8解码为字符串
    # recv方法的传参是buffsize,缓冲区大小，一般设置为1024即可
    if data == 'exit':
        break
    print("接收到发送来的数据：",data)
# 可以通过while True 无限循环来持续和客户端进行数据交互
# 可以通过判定客户端发来的特殊标记，如exit，来退出无限循环
```

6. 通过conn(客户端当次连接对象)，调用send方法可以回复消息
```py
while True:
    data = conn.recv(1024).decode("UTF-8")
    if data == 'exit':
        break
    print("接收到发送来的数据：",data)

    conn.send("你好呀哈哈哈哈".encode("UTF-8"))
```

7. conn(客户端当次连接对象)和socket_server对象调用close方法，关闭连接