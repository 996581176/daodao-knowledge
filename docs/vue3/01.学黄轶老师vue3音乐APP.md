---
title: 学黄轶老师vue3音乐APP
date: 2021-07-26 15:33:58
permalink: /pages/f97ef5/
categories:
  - vue3
tags:
    -
---
学习黄老师的音乐app课程有一段时间了，学到了很多之前不知道的花式骚操作，怕自己忘了，记录一下自己学习的收获

## 第二章 项目初始化和推荐页面开发

### 如何使用脚手架创建vue3项目
1. 运行 vue creat vue-music-next,其中vue-music-next是新建的项目的名字，可以随便写
2. 然后选择Manually select features （手动的去选择）
然后最主要的是vue版本选3，其他的随意

### 项目中数据mock方案
黄老师的项目中数据使用的是真实接口的数据，但是真实接口数据会有跨域的问题，服务端是不存在跨域的，所以使用`webpack`的`devServer`来解决一下:  
`devServer.before`提供了一个在 `devServer` 内部的 所有中间件执行之前的自定义执行函数,所以可以利用它来模拟接口：
例： 在vue.config.js中如下定义：
```js 
//vue.config.js
module.exports = {
    css: {
        loaderOptions:{
            sass: {
                //全局引入变量和 mixin
                prependData: `
                    @import "@/assets/scss/variable.scss";
                    @import "@/assets/scss/mixin.scss";
                `
            }
        }
    },
    devServer: {
        before(app) {
            app.get('/some/path', function (req, res) {
                res.json({ custom: 'response' });
            });
        }
    }
}
```
然后就可以在项目中使用接口：
```js
axios.get('/some/path').then((res) => {
    this.data = res.data // {custom:'response'}
})
```

### 这是API模板引用(ref)
在使用组合式 API 时，`响应式引`用和`模板引用`的概念是统一的。为了获得对模板内元素或组件实例的引用，我们可以像往常一样声明 `ref` 并从 `setup()` 返回：
```vue
<template> 
  <div ref="root">This is a root element</div>
</template>

<script>
  import { ref, onMounted } from 'vue'

  export default {
    setup() {
      const root = ref(null)

      onMounted(() => {
        // DOM元素将在初始渲染后分配给ref
        console.log(root.value) // <div>这是根元素</div>
      })

      return {
        root
      }
    }
  }
</script>
```
这里我们在渲染上下文中暴露 `root`，并通过 `ref="root"`，将其绑定到 `div` 作为其 `ref`。在`虚拟 DOM 补丁`算法中，如果 `VNode` 的 `ref` 键对应于渲染上下文中的 `ref`，则 `VNode` 的相应元素或组件实例将被分配给该 `ref` 的值。这是在虚拟 DOM 挂载/打补丁过程中执行的，因此模板引用只会在初始渲染之后获得赋值。

作为模板使用的 `ref` 的行为与任何其他 `ref` 一样：它们是响应式的，可以传递到 (或从中返回) 复合函数中。
### 滚动组件封装
首先写好基本的模板
```vue
<template>
  <div>
    <slot></slot>
  </div>
</template>
```
使用插槽的形式，滚动的内容部分可用放到插槽的那一块，然后外层可用和`betterScroll`做一些初始化的联动。使用`compositionAPI`和钩子函数的方式。  
所以再新建一个js文件`use-scroll.js`
```js
import BScroll from '@better-scroll/core'
import ObserveDOM from '@/better-scroll/observe-dom' //自动探测DOM的高度
import { onMounted, onUnmounted, ref } from 'vue'

BScroll.use(ObserveDOM)

export default function useScroll(wrapperRef) {
  const scroll = ref(null)

  onMounted(() => {
    scroll.value = new BScroll(wrapperRef.value, {
      observeDOM: true
    })
  })

  onUnmounted(() => {
    scroll.value.destroy()
  })
}
```
在这里面暴露一个函数`useScroll`,传入一个`ref`对象。  
首先定义一个`scroll`的`ref`对象，表示这个`scroll`对象是响应式的。  
在`onMounted`钩子函数中拿到对应的DOM，实现betterScroll的初始化。  
在`onUnMounted`钩子函数中去执行`scroll`实例的卸载逻辑。

下面在`scroll`组件种去引用它：
```vue
<template>
  <div ref="rootRef">
    <slot></slot>
  </div>
</template>

<script>
  import useScroll from './use-scroll'
  import { ref } from 'vue'

  export default {
    name: 'scroll',
    setup() {
      const rootRef = ref(null)
      useScroll(rootRef)

      return {
        rootRef
      }
    }
  }
</script>
```
先引入`useScroll`，因为我们使用`compositionAPI`,所以我们在`setup()`函数中去调`useScroll`的函数，要传入一个ref对象，所以要定义一个`rootRef`。
使用`compositionAPI`后，很多东西都要手动去定义响应式。`const rootRef = ref(null)`,定义好了之后一定要`return`，不然不会生效。

这个滚动组件是比较简单的，我们加`props`增加可以自定义的参数。
```js
props: {
  click: {
    type: Boolean,
    default: true
  }
}
```
然后我们需要把`props`传递给初始化scroll的方法。首先给`useScroll`函数扩展一个`options`参数：
```js
//...
export default function useScroll(wrapperRef, options) {
//...  
  onMounted(() => {
    scroll.value = new BScroll(wrapperRef.value, {
      observeDOM: true,
      ...options
    })
  })
//...  
```

然后在`setup`函数中拿到`props`，然后在使用`useScroll`时，传递`props`：
```js
//...
setup(props) {
  //...
  userScroll(rootRef, props)
  //...
}
```

### v-loading自定义指令开发
### composition API
### watch
### computed