---
title: 期约
date: 2021-06-09 10:52:06
permalink: /pages/9ba128/
categories:
  - javascript
  - 期约与异步函数
tags:
    -
---
## 期约基础
ECMAScript6 新增的引用类型`Promise`，可以通过`new`操作符来实例化。创建新期约时需要传入执行器(executor)函数作为参数，下面例子使用了一个空函数对象来应付一下解释器：
```js
let p = new Promise(() => {})
setTimeout(console.log,0,p) // Promise<pending>
```
之所以说是应付解释器，是因为如果不提供执行函数，就会抛出`SyntaxError`。

### 1.期约状态机
在把一个期约实例传给`console.log()`时，控制台输出（可能因浏览器不同而略有差异）表明该实例处于**待定**（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下3种状态之一：
- 待定（pending）
- 兑现（fulfilled，有时候也称为“解决”，resolved）
- 拒绝（rejected）

**待定**（pending）是期约的最初始状态。在待定状态下，期约可以落定为代表成功的**兑现**（fulfilled）状态，或者代表失败的**拒绝**（rejected）状态。无论落为哪种状态都是不可逆的。只要从待定转换为兑现或者拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约解决（resolve）还是拒绝（reject），甚至永远处于待定（pending）状态，都应该有恰当的行为。

重要的是，期约的状态是私有的，不能直接通过JavaScript检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部JavaScript代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。

### 2.通过执行函数控制期约状态
由于期约状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为`resolve()`和`reject()`。调用`resolve()`会把状态切换成兑现，调用`reject()`会把状态切换为拒绝。另外，调用`reject()`也会抛出错误。

```js
let p1 = new Promise((resolve,reject) => resolve())
setTimeout(console.log,0,p1) //Promise<resolved>

let p1 = new Promise((resolve,reject) => reject())
setTimeout(console.log,0,p1) //Promise<rejected>
//Uncaught error(in promise)
```

在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态。这里的关键在于，执行器函数是**同步**执行的。这是因为执行器函数是期约的初始化程序。通过下面的例子可以看出上面代码的执行顺序：
```js
new Promise(() => setTimeout(console.log,0,'executor'))
setTimeout(console.log,0,'promise initialized')

// executor
// promise initialized
```
添加`setTimeout`可以推迟切换状态：
```js
let p = new Promise((resolve,reject) => setTimeout(resolve,1000))
//在console.log打印期约实例的时候，还不会执行超时回调（即resolve()）
setTimeout(console.log,0,p) //Promise<pending>
```
无论`resolve()`和`reject()`中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败：
```js
let p = new Promise((resolve,reject) => {
  resolve()
  reject() //没有效果
})
setTimeout(console.log,0,p) // Promise<resolved>
```
为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过`setTimeout`设置一个10秒钟后无论如何都会拒绝期约的回调：
```js
let p = new Promise((resolve,reject) => {
  setTimeout(reject,10000) //10秒后调用reject()
  //执行函数的逻辑
})

setTimeout(console.log,0,p) //Promise<pending>
setTimeout(console.log,11000,p) //11秒后检查状态

//(After 10 seconds) Uncaught error
//(After 11 seconds) Promise<rejected>
```
因为期约状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失效。

### 3.Promise.resolve()
期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用`Promise.resolve()`静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的：
```js

```

<script>
let p = new Promise((resolve,reject) => {
  resolve()
  reject() //没有效果
})
setTimeout(console.log,0,p) // Promise<resolved>
</script>