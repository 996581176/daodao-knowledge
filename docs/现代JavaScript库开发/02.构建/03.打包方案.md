---
title: 打包方案
date: 2023-03-12 22:09:02
permalink: /pages/95ed34/
categories:
  - 现代JavaScript库开发
  - 构建
tags:
    -
---
前面介绍了在不同的模块规范和不同的前端技术体系下，库的适配原理。这部分内容细致又琐碎，使用手动配置的方式会相当麻烦，那么有没有更好的办法呢？

目前比较好的办法就是使用打包工具自动完成打包工作。

根据前面两节的内容，开源库需要支持浏览器、打包工具和Node.js环境，以及不同的模块规范，所以需要提供不同的入口文件。

|         |浏览器(script,AMD,CMD)|打包工具(webpack、rollup.js)|Node.js  |
|---------|----------------------|---------------------------|---------|
|入口文件  |index.aio.js          |index.esm.js               |index.js |
|模块规范  |UMD                   |ES Module                  |CommonJS |
|自身依赖  |打包                  |打包                        |打包     |
|第三方依赖|打包                  |不打包                      |不打包    |

## 选择打包工具
既然已经确定了目标，那么接下来就需要选择一款合适的打包工具。JaveScipt社区大多选择`webpack`和`rollup.js`作为库的打包工具，`webpack`是现在非常流行的打包工具，而`rollup.js`则被称作下一代打包工具，**推荐使用rollup.js作为库的打包工具**。

为什么不使用我们更熟悉的webpack呢？我们通过具体示例来对比webpack和rollup.js。假设有两个文件：index.js和bar.js

bar.js对外暴露一个bar函数，代码如下：
```js
export default function bar() {
    console.log('bar')
}
```
index.js文件引用bar.js文件，代码如下：
```js
import bar from './bar'
bar()
```

`webpack`打包输出的内容，`index.js`和`bar.js`文件的内容在打包内容的最下面。`webpack`方案的问题在于会生成很多冗余代码，这对于业务代码来说问题不大，但是对于库来说就不太友好了。
::: tip 最新发现
但是我试了一下，webpack5打包的内容并没有那么多冗余,以下是webpack5打包内容。(不过webpack34确实有很多冗余)
```js
(()=>{"use strict";console.log("bar")})();
```
:::

下面的代码是`rollup.js`打包输出的内容，可以看到模块完全消失了。那么`rollup.js`如何解决模块之间的依赖问题呢？对于打包的代码，`rollup.js`巧妙地通过将被依赖的模块放在依赖模块前面的方法来解决模块依赖问题。对比`webpack`打包后的代码，`rollup.js`的打包方案对于库的开发者来说是接近完美的方案。
```js
'use strict'

function bar() {
    console.log('bar')
}

bar()
```

## 打包步骤
首先安装rollup.js,命令如下：
```
npm i --save-dev rollup@0.57.1
```
由于只在开发时才会用到`rollup.js`，因此我们通过上面的参数`--save-dev`将其安装为开发时依赖，这样会将依赖添加到`package.json`文件的`DevDependencies`字段中，代码如下：
```json
{
    "devDependencies":{
        "rollup": "^0.57.1"
    }
}
```
rollup.js的使用方式和webpack的使用方式类似，需要通过配置文件告诉rollup.js如何打包。根据上表的结论，存在3种入口文件，因此需要3个配置文件，