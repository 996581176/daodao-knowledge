---
title: 学黄轶老师vue3音乐APP
date: 2021-07-26 15:33:58
permalink: /pages/f97ef5/
categories:
  - vue3
tags:
    -
---
学习黄老师的音乐app课程有一段时间了，学到了很多之前不知道的花式骚操作，怕自己忘了，记录一下自己学习的收获

## 第二章 项目初始化和推荐页面开发

### 如何使用脚手架创建vue3项目
1. 运行 vue creat vue-music-next,其中vue-music-next是新建的项目的名字，可以随便写
2. 然后选择Manually select features （手动的去选择）
然后最主要的是vue版本选3，其他的随意

### 项目中数据mock方案
黄老师的项目中数据使用的是真实接口的数据，但是真实接口数据会有跨域的问题，服务端是不存在跨域的，所以使用`webpack`的`devServer`来解决一下:  
`devServer.before`提供了一个在 `devServer` 内部的 所有中间件执行之前的自定义执行函数,所以可以利用它来模拟接口：
例： 在vue.config.js中如下定义：
```js 
//vue.config.js
module.exports = {
    css: {
        loaderOptions:{
            sass: {
                //全局引入变量和 mixin
                prependData: `
                    @import "@/assets/scss/variable.scss";
                    @import "@/assets/scss/mixin.scss";
                `
            }
        }
    },
    devServer: {
        before(app) {
            app.get('/some/path', function (req, res) {
                res.json({ custom: 'response' });
            });
        }
    }
}
```
然后就可以在项目中使用接口：
```js
axios.get('/some/path').then((res) => {
    this.data = res.data // {custom:'response'}
})
```

### 这是API模板引用(ref)
在使用组合式 API 时，`响应式引`用和`模板引用`的概念是统一的。为了获得对模板内元素或组件实例的引用，我们可以像往常一样声明 `ref` 并从 `setup()` 返回：
```vue
<template> 
  <div ref="root">This is a root element</div>
</template>

<script>
  import { ref, onMounted } from 'vue'

  export default {
    setup() {
      const root = ref(null)

      onMounted(() => {
        // DOM元素将在初始渲染后分配给ref
        console.log(root.value) // <div>这是根元素</div>
      })

      return {
        root
      }
    }
  }
</script>
```
这里我们在渲染上下文中暴露 `root`，并通过 `ref="root"`，将其绑定到 `div` 作为其 `ref`。在`虚拟 DOM 补丁`算法中，如果 `VNode` 的 `ref` 键对应于渲染上下文中的 `ref`，则 `VNode` 的相应元素或组件实例将被分配给该 `ref` 的值。这是在虚拟 DOM 挂载/打补丁过程中执行的，因此模板引用只会在初始渲染之后获得赋值。

作为模板使用的 `ref` 的行为与任何其他 `ref` 一样：它们是响应式的，可以传递到 (或从中返回) 复合函数中。
### 滚动组件封装
首先写好基本的模板
```vue
<template>
  <div>
    <slot></slot>
  </div>
</template>
```
使用插槽的形式，滚动的内容部分可用放到插槽的那一块，然后外层可用和`betterScroll`做一些初始化的联动。使用`compositionAPI`和钩子函数的方式。  
所以再新建一个js文件`use-scroll.js`
```js
import BScroll from '@better-scroll/core'
import ObserveDOM from '@/better-scroll/observe-dom' //自动探测DOM的高度
import { onMounted, onUnmounted, ref } from 'vue'

BScroll.use(ObserveDOM)

export default function useScroll(wrapperRef) {
  const scroll = ref(null)

  onMounted(() => {
    scroll.value = new BScroll(wrapperRef.value, {
      observeDOM: true
    })
  })

  onUnmounted(() => {
    scroll.value.destroy()
  })
}
```
在这里面暴露一个函数`useScroll`,传入一个`ref`对象。  
首先定义一个`scroll`的`ref`对象，表示这个`scroll`对象是响应式的。  
在`onMounted`钩子函数中拿到对应的DOM，实现betterScroll的初始化。  
在`onUnMounted`钩子函数中去执行`scroll`实例的卸载逻辑。

下面在`scroll`组件种去引用它：
```vue
<template>
  <div ref="rootRef">
    <slot></slot>
  </div>
</template>

<script>
  import useScroll from './use-scroll'
  import { ref } from 'vue'

  export default {
    name: 'scroll',
    setup() {
      const rootRef = ref(null)
      useScroll(rootRef)

      return {
        rootRef
      }
    }
  }
</script>
```
先引入`useScroll`，因为我们使用`compositionAPI`,所以我们在`setup()`函数中去调`useScroll`的函数，要传入一个ref对象，所以要定义一个`rootRef`。
使用`compositionAPI`后，很多东西都要手动去定义响应式。`const rootRef = ref(null)`,定义好了之后一定要`return`，不然不会生效。

这个滚动组件是比较简单的，我们加`props`增加可以自定义的参数。
```js
props: {
  click: {
    type: Boolean,
    default: true
  }
}
```
然后我们需要把`props`传递给初始化scroll的方法。首先给`useScroll`函数扩展一个`options`参数：
```js
//...
export default function useScroll(wrapperRef, options) {
//...  
  onMounted(() => {
    scroll.value = new BScroll(wrapperRef.value, {
      observeDOM: true,
      ...options
    })
  })
//...  
```

然后在`setup`函数中拿到`props`，然后在使用`useScroll`时，传递`props`：
```js
//...
setup(props) {
  //...
  userScroll(rootRef, props)
  //...
}
```

### v-loading自定义指令开发
首先开发一个`loading`组件，loading组件很简单，但是这样直接用不优雅，所以可以实现一个`v-loading`的自定义指令。vue3的自定义指令和vue2略有不同。  

指令作用是把loading组件动态插入到指令作用的对象内部  
那我们怎么创建组件对应的DOM呢？我们也是可以新建一个vue实例，创建一个新的app对象，然后用loading组件，然后我们再动态去挂载，然后产生一个实例，在实例里面就可以拿到它的DOM对象。
```js
import { createApp } from 'vue'
import Loading from './loading'

cosnt loadingDirective = {
  mounted(el, binding) {
    const app = createApp(Loading)
    const instance = app.mount(document.createElement('div'))
    el.instance = instance

    if(binding.value) {
      append(el)
    }
  },
  updated(el, binding) {
    if(binding.value !== binding.oldValue) {
      binding.value ? append(el) : remove(el)
    }
  }
}

function append(el) {
  el.appendChild(el.instance.$el)
}

function remove(el) {
  el.removeChild(el.instance.$el)
}

export default loadingDirective
```
实际上vue开发其实它是多实例的，并不是说只能在入口里面就创建一个唯一的App实例，我们是在其他地方也可以利用`createApp`api去创建一个新的实例，然而这个实例挂载的地方是一个动态创建的div,这个div并没有实质上的DOM层的挂载，为什么不要挂载到DOM上呢，因为它挂载的目的很明确，它要挂载到el上。这个loading还有一些定位的问题，不过这个很简单，只是以后写的时候需要注意。
### composition API
`setup`选项在组件创建之前执行,一旦`props`被解析，就将作为组合式API的入口。  
`setip`选项是一个接受`props`和`context`的函数。此外，我们将`setup`返回的所有内容都暴露给组件的其余部分（计算属性、方法、生命周期钩子等等）以及组件的模板。

#### 带ref的响应式变量
在Vue3.0中，我们可以通过一个新的ref函数使任何响应式变量在任何地方起作用，ref接收参数并将其包裹在一个带有value property的对象中返回，返回可以使该property访问或更改响应式变量的值。

#### 在setup内注册声明周期钩子
组合式API上的声明周期钩子与选项式API的名称相同，但前缀为on

#### watch响应式更改
就像在组件中使用watch选项上设置侦听器一样，我们也可以从Vue导入的watch函数执行相同的操作。它接受3个参数：
- 一个想要侦听的响应式引用或getter函数
- 一个回调
- 可选的配置选项

我们只能将顶层的 data、props 或 computed property 名作为字符串传递。对于更复杂的表达式，用一个函数取代。

#### 独立的computed属性
与ref和watch类似，也可以使用从Vue导入的computed函数在Vue组件外创建计算属性。
```js
import { ref, computed } from 'vue'

const counter = ref(0)
const twiceTheCounter = computed(() => counter.value * 2)

counter.value++
console.log(counter.value) // 1
console.log(twiceTheCounter.value) // 2
```
这里我们给computed函数传递了第一个参数，它是一个类似getter的回调函数，输出的是一个**只读的响应式引用**。为了访问新创建的计算变量的value,我们需要像ref一样使用.value property。 

### 歌手列表和字母表如何关联
1.首先将歌手列表渲染出来
2.然后计算每个字母的列表的高度，并将它们存在一个数组里，这将是以后判断当前列表滚动到哪里的重要依据
3.滚动的时候将当前滚动高度返回出来，并且监听这个高度，计算出当前字母的index
4.在字母列表上滑动的时候，也是根据滑动的高度，去改变这个index，由此将二者联系起来
### 歌手列表的当前的字母如何写动画
1.在滚动列表的时候，计算当前字母歌手列表的底部距离顶部有多少距离
2.当小于一个标题高度的时候，改变标题的translate3d的y分量。