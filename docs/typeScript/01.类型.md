---
title: 类型
date: 2023-02-26 14:22:59
permalink: /pages/450a09/
categories:
  - typeScript
tags:
    -
---
## 起航
TypeScript是JavaScript的超集，本来呢，我对它并不感兴趣，但是现在大势所趋，我还是必须得学了额。

## 类型
TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便使用。
### 布尔值 boolean
```ts
let isDone:boolean = false
```

### 数字 number
和JavaScript一样，ts里所有的数字都是浮点数，这些浮点数的类型是`number`,支持十进制，八进制，二进制，十六进制，还支持`Infinity`和`NaN`
```ts
let decLiteral:number = 6
let hexLiteral:number = 0xf00d
let binaryLiteral:number = 0b1010
let octalLiteral:number = 0o774
let infinityNumber:number = Infinity
let nanNumber:number = NaN
```

### 字符串 string
```ts
let name:string = "bob"
name = "smith"
```
还可以使用模板字符串，它可以定义多行文本和内嵌表达式。
```ts
let myname:string = `Gene`
let age:number = 37
let sentence:string = `Hello, my name is ${myname}.
I'll be ${age + 1} years old next month.`
// Hello, my name is Gene.        
//I'll be 38 years old next month.
```

### any 和 unknown
any:任意类型， unknown:不知道的类型  
ts中类型有六个层级，上级的类型可以包含下级的所有类型：
1. top type 顶级类型： any, unknown 
2. Object
3. Number String Boolean
4. number string boolean
5. 普通的数字，普通字符串，true/false
6. never
```ts
let a:unknown = 1
let b:any = '123'
let c:number = 12
let d:unknown = {'name':'daodao'}

a = b
b = a
a = c
c = a // 报错，unknown不能给number类型赋值
console.log(d.name) //报错，unknown不可以读任何属性
```
需要注意的是，unknown只能赋值给自身或者是any，不能给别的类型赋值，而且无法读任何属性，方法也不可以调用。

### Object object 以及 {}
- Object:
    原型链的顶端其实就是Object,也就是意味着所有的原始类型以及对象类型最终都指向Objet,因此，在ts中Object就表示包含了所有的类型，它可以等于任何一个值。
    ```ts
    let a:Object = 1
    a = {'name':'abc'}
    a = 'str'
    ```

- object
    常用语泛型约束，表示非原始类型，也就是除`number`,`string`,`boolean`,`symbol`,`null`或`undefined`之外的类型
    ```ts
    let a:object = {'name':'abc'}
    a = 1 //报错
    a = 'str' //报错
    ```
- {}
    和Object一样，可以为任何类型，但是不允许修改里面没有的属性值
    ```ts
    let c:{} = {'a':123}
    c.a = 456 //报错
    c.b = 'dfa' //报错
    ```

### 数组
- 定义普通数组类型
```ts
let arr:number[] = [1,2,3,4,5]
let arr1:boolean[] = [true,false]
let arr2:Array<number> = [1,2,3]
```

- 定义对象数组
```ts
interface X {
    name:string
}

let arr3:X[] = [{name:'daodao'},{name:'mimi'}]
```

- 定义二维数组
```ts
let arr4:number[][] = [[1],[2],[3]]
let arr5:Array<Array<number>> = [[1],[2],[3]]
```

- 大杂烩数组
```ts
let arr6:any[] = [1,'str',true, {}]
// 也可以用元祖
let arr7:[number,string,boolean,{}] = [1,'str',true, {}]
```

- 定义函数的剩余参数类型
```ts
function a(...args:number[]) {
    console.log(args)
    // arguments是一个类数组，定义它可以用ts内置类型 IArguments
    let a:IArguments = arguments
}

a(1,2,3) // [1,2,3]
```

## 接口
接口就是对值的结构进行类型检查，接口和值不能多属性也不能少属性。
```ts
interface Example {
    name: string;
    age:number;
}

let a:Example = {
    name:'daodao',
    age:18
}
```

### 接口重名
重名的两个接口会合并成为一个接口
```ts
interface A {
    name:string;
    age:number;
}
interface A {
    money:number
}
let daodao:A = {
    name:'daodao',
    age:18,
    money:1000000000000
}
```

### 任意key
有时候实在不能把每个属性都列举出来，比如后端返回了其他的属性
```ts
interface B {
    name:string;
    age:number;
    [propName:string]:any;
}
let b:B = {
    name:'b',
    age:100,
    a:1,
    b:2,
    c:3
}
```

### 只读和可缺省属性
有的属性比如id，并不希望它能被外部修改，可以加上readonly变为只读属性，而有的属性可有可无，可以加？代表可缺省
```ts
interface C{
    readonly id:number;
    name:string;
    age?:number;
    readonly cb:() => boolean;
}
let c:C = {
    id:1,
    name:'c',
    cb:() => {
        return false
    }
}
```

### 接口继承
接口继承和接口重名类似
```ts
interface D {
    name:string
}
interface E extends D {
    age:number
}

let e:E = {
    name:'e',
    age:20
}
```

### 定义函数
定义函数类型就想一个只有参数列表和返回值类型的函数定义
```ts
interface Fn {
    (name:string):number[]
}

const fn:Fn = function(name:string) {
    return [1]
}
```